diff --git a/include/mysql_com.h b/include/mysql_com.h
index 357519d..93f124c 100644
--- a/include/mysql_com.h
+++ b/include/mysql_com.h
@@ -113,8 +113,15 @@ enum enum_server_command
 #define REFRESH_THREADS		32	/* Flush thread cache */
 #define REFRESH_SLAVE           64      /* Reset master info and restart slave
 					   thread */
-#define REFRESH_MASTER          128     /* Remove all bin logs in the index
+#define REFRESH_MASTER		128     /* Remove all bin logs in the index
 					   and truncate the index */
+#define REFRESH_TABLE_STATS	256	/* Refresh table stats hash table */
+#define REFRESH_INDEX_STATS	512	/* Refresh index stats hash table */
+#define REFRESH_USER_STATS	1024	/* Refresh user stats hash table */
+					/* What about 2048? */
+#define REFRESH_SLOW_QUERY_LOG	4096	/* Flush slow query log and rotata*/
+#define REFRESH_CLIENT_STATS	8192	/* Refresh client stats hash table */
+
 
 /* The following can't be set with mysql_refresh() */
 #define REFRESH_READ_LOCK	16384	/* Lock tables for read */
diff --git a/mysql-test/r/information_schema.result b/mysql-test/r/information_schema.result
index 0da9ed4..54e4be7 100644
--- a/mysql-test/r/information_schema.result
+++ b/mysql-test/r/information_schema.result
@@ -44,6 +44,7 @@ table_name<>'ndb_apply_status';
 select * from v1;
 c
 CHARACTER_SETS
+CLIENT_STATISTICS
 COLLATIONS
 COLLATION_CHARACTER_SET_APPLICABILITY
 COLUMNS
@@ -53,6 +54,7 @@ EVENTS
 FILES
 GLOBAL_STATUS
 GLOBAL_VARIABLES
+INDEX_STATISTICS
 KEY_COLUMN_USAGE
 PARTITIONS
 PLUGINS
@@ -68,8 +70,10 @@ STATISTICS
 TABLES
 TABLE_CONSTRAINTS
 TABLE_PRIVILEGES
+TABLE_STATISTICS
 TRIGGERS
 USER_PRIVILEGES
+USER_STATISTICS
 VIEWS
 columns_priv
 db
@@ -106,6 +110,7 @@ c	table_name
 TABLES	TABLES
 TABLE_CONSTRAINTS	TABLE_CONSTRAINTS
 TABLE_PRIVILEGES	TABLE_PRIVILEGES
+TABLE_STATISTICS	TABLE_STATISTICS
 TRIGGERS	TRIGGERS
 tables_priv	tables_priv
 time_zone	time_zone
@@ -125,6 +130,7 @@ c	table_name
 TABLES	TABLES
 TABLE_CONSTRAINTS	TABLE_CONSTRAINTS
 TABLE_PRIVILEGES	TABLE_PRIVILEGES
+TABLE_STATISTICS	TABLE_STATISTICS
 TRIGGERS	TRIGGERS
 tables_priv	tables_priv
 time_zone	time_zone
@@ -144,6 +150,7 @@ c	table_name
 TABLES	TABLES
 TABLE_CONSTRAINTS	TABLE_CONSTRAINTS
 TABLE_PRIVILEGES	TABLE_PRIVILEGES
+TABLE_STATISTICS	TABLE_STATISTICS
 TRIGGERS	TRIGGERS
 tables_priv	tables_priv
 time_zone	time_zone
@@ -625,12 +632,14 @@ from information_schema.tables
 where table_schema='information_schema' limit 2;
 TABLE_NAME	TABLE_TYPE	ENGINE
 CHARACTER_SETS	SYSTEM VIEW	MEMORY
+CLIENT_STATISTICS	SYSTEM VIEW	MEMORY
 COLLATIONS	SYSTEM VIEW	MEMORY
 show tables from information_schema like "T%";
 Tables_in_information_schema (T%)
 TABLES
 TABLE_CONSTRAINTS
 TABLE_PRIVILEGES
+TABLE_STATISTICS
 TRIGGERS
 create database information_schema;
 ERROR 42000: Access denied for user 'root'@'localhost' to database 'information_schema'
@@ -640,6 +649,7 @@ Tables_in_information_schema (T%)	Table_type
 TABLES	SYSTEM VIEW
 TABLE_CONSTRAINTS	SYSTEM VIEW
 TABLE_PRIVILEGES	SYSTEM VIEW
+TABLE_STATISTICS	SYSTEM VIEW
 TRIGGERS	SYSTEM VIEW
 create table t1(a int);
 ERROR 42S02: Unknown table 't1' in information_schema
@@ -652,6 +662,7 @@ Tables_in_information_schema (T%)
 TABLES
 TABLE_CONSTRAINTS
 TABLE_PRIVILEGES
+TABLE_STATISTICS
 TRIGGERS
 select table_name from tables where table_name='user';
 table_name
@@ -839,6 +850,7 @@ TABLE_NAME	COLUMN_NAME	PRIVILEGES
 COLUMNS	TABLE_NAME	select
 COLUMN_PRIVILEGES	TABLE_NAME	select
 FILES	TABLE_NAME	select
+INDEX_STATISTICS	TABLE_NAME	select
 KEY_COLUMN_USAGE	TABLE_NAME	select
 PARTITIONS	TABLE_NAME	select
 REFERENTIAL_CONSTRAINTS	TABLE_NAME	select
@@ -846,13 +858,14 @@ STATISTICS	TABLE_NAME	select
 TABLES	TABLE_NAME	select
 TABLE_CONSTRAINTS	TABLE_NAME	select
 TABLE_PRIVILEGES	TABLE_NAME	select
+TABLE_STATISTICS	TABLE_NAME	select
 VIEWS	TABLE_NAME	select
 delete from mysql.user where user='mysqltest_4';
 delete from mysql.db where user='mysqltest_4';
 flush privileges;
 SELECT table_schema, count(*) FROM information_schema.TABLES WHERE table_schema IN ('mysql', 'INFORMATION_SCHEMA', 'test', 'mysqltest') AND table_name<>'ndb_binlog_index' AND table_name<>'ndb_apply_status' GROUP BY TABLE_SCHEMA;
 table_schema	count(*)
-information_schema	28
+information_schema	32
 mysql	22
 create table t1 (i int, j int);
 create trigger trg1 before insert on t1 for each row
@@ -1240,6 +1253,7 @@ c2.column_name LIKE '%SCHEMA%'
         );
 table_name	column_name
 CHARACTER_SETS	CHARACTER_SET_NAME
+CLIENT_STATISTICS	CLIENT
 COLLATIONS	COLLATION_NAME
 COLLATION_CHARACTER_SET_APPLICABILITY	COLLATION_NAME
 COLUMNS	TABLE_SCHEMA
@@ -1249,6 +1263,7 @@ EVENTS	EVENT_SCHEMA
 FILES	TABLE_SCHEMA
 GLOBAL_STATUS	VARIABLE_NAME
 GLOBAL_VARIABLES	VARIABLE_NAME
+INDEX_STATISTICS	TABLE_SCHEMA
 KEY_COLUMN_USAGE	CONSTRAINT_SCHEMA
 PARTITIONS	TABLE_SCHEMA
 PLUGINS	PLUGIN_NAME
@@ -1264,8 +1279,10 @@ STATISTICS	TABLE_SCHEMA
 TABLES	TABLE_SCHEMA
 TABLE_CONSTRAINTS	CONSTRAINT_SCHEMA
 TABLE_PRIVILEGES	TABLE_SCHEMA
+TABLE_STATISTICS	TABLE_SCHEMA
 TRIGGERS	TRIGGER_SCHEMA
 USER_PRIVILEGES	GRANTEE
+USER_STATISTICS	USER
 VIEWS	TABLE_SCHEMA
 SELECT t.table_name, c1.column_name
 FROM information_schema.tables t
@@ -1283,6 +1300,7 @@ c2.column_name LIKE '%SCHEMA%'
         );
 table_name	column_name
 CHARACTER_SETS	CHARACTER_SET_NAME
+CLIENT_STATISTICS	CLIENT
 COLLATIONS	COLLATION_NAME
 COLLATION_CHARACTER_SET_APPLICABILITY	COLLATION_NAME
 COLUMNS	TABLE_SCHEMA
@@ -1292,6 +1310,7 @@ EVENTS	EVENT_SCHEMA
 FILES	TABLE_SCHEMA
 GLOBAL_STATUS	VARIABLE_NAME
 GLOBAL_VARIABLES	VARIABLE_NAME
+INDEX_STATISTICS	TABLE_SCHEMA
 KEY_COLUMN_USAGE	CONSTRAINT_SCHEMA
 PARTITIONS	TABLE_SCHEMA
 PLUGINS	PLUGIN_NAME
@@ -1307,8 +1326,11 @@ STATISTICS	TABLE_SCHEMA
 TABLES	TABLE_SCHEMA
 TABLE_CONSTRAINTS	CONSTRAINT_SCHEMA
 TABLE_PRIVILEGES	TABLE_SCHEMA
+TABLE_STATISTICS	TABLE_SCHEMA
 TRIGGERS	TRIGGER_SCHEMA
+USER_MAP	FROM_USER
 USER_PRIVILEGES	GRANTEE
+USER_STATISTICS	USER
 VIEWS	TABLE_SCHEMA
 SELECT MAX(table_name) FROM information_schema.tables WHERE table_schema IN ('mysql', 'INFORMATION_SCHEMA', 'test');
 MAX(table_name)
@@ -1377,6 +1399,7 @@ group by c2.column_type order by num limit 1)
 group by t.table_name order by num1, t.table_name;
 table_name	group_concat(t.table_schema, '.', t.table_name)	num1
 CHARACTER_SETS	information_schema.CHARACTER_SETS	1
+CLIENT_STATISTICS	information_schema.CLIENT_STATISTICS	1
 COLLATIONS	information_schema.COLLATIONS	1
 COLLATION_CHARACTER_SET_APPLICABILITY	information_schema.COLLATION_CHARACTER_SET_APPLICABILITY	1
 COLUMNS	information_schema.COLUMNS	1
@@ -1386,6 +1409,7 @@ EVENTS	information_schema.EVENTS	1
 FILES	information_schema.FILES	1
 GLOBAL_STATUS	information_schema.GLOBAL_STATUS	1
 GLOBAL_VARIABLES	information_schema.GLOBAL_VARIABLES	1
+INDEX_STATISTICS	information_schema.INDEX_STATISTICS	1
 KEY_COLUMN_USAGE	information_schema.KEY_COLUMN_USAGE	1
 PARTITIONS	information_schema.PARTITIONS	1
 PLUGINS	information_schema.PLUGINS	1
@@ -1401,8 +1425,11 @@ STATISTICS	information_schema.STATISTICS	1
 TABLES	information_schema.TABLES	1
 TABLE_CONSTRAINTS	information_schema.TABLE_CONSTRAINTS	1
 TABLE_PRIVILEGES	information_schema.TABLE_PRIVILEGES	1
+TABLE_STATISTICS	information_schema.TABLE_STATISTICS	1
 TRIGGERS	information_schema.TRIGGERS	1
+USER_MAP	information_schema.USER_MAP	1
 USER_PRIVILEGES	information_schema.USER_PRIVILEGES	1
+USER_STATISTICS	information_schema.USER_STATISTICS	1
 VIEWS	information_schema.VIEWS	1
 create table t1(f1 int);
 create view v1 as select f1+1 as a from t1;
diff --git a/mysql-test/r/information_schema_db.result b/mysql-test/r/information_schema_db.result
index 2e3fa7f..3496f0b 100644
--- a/mysql-test/r/information_schema_db.result
+++ b/mysql-test/r/information_schema_db.result
@@ -6,6 +6,7 @@ use INFORMATION_SCHEMA;
 show tables;
 Tables_in_information_schema
 CHARACTER_SETS
+CLIENT_STATISTICS
 COLLATIONS
 COLLATION_CHARACTER_SET_APPLICABILITY
 COLUMNS
@@ -15,6 +16,7 @@ EVENTS
 FILES
 GLOBAL_STATUS
 GLOBAL_VARIABLES
+INDEX_STATISTICS
 KEY_COLUMN_USAGE
 PARTITIONS
 PLUGINS
@@ -30,14 +32,17 @@ STATISTICS
 TABLES
 TABLE_CONSTRAINTS
 TABLE_PRIVILEGES
+TABLE_STATISTICS
 TRIGGERS
 USER_PRIVILEGES
+USER_STATISTICS
 VIEWS
 show tables from INFORMATION_SCHEMA like 'T%';
 Tables_in_information_schema (T%)
 TABLES
 TABLE_CONSTRAINTS
 TABLE_PRIVILEGES
+TABLE_STATISTICS
 TRIGGERS
 create database `inf%`;
 create database mbase;
diff --git a/mysql-test/r/mysqlshow.result b/mysql-test/r/mysqlshow.result
index 42081c3..6007ea3 100644
--- a/mysql-test/r/mysqlshow.result
+++ b/mysql-test/r/mysqlshow.result
@@ -80,6 +80,7 @@ Database: information_schema
 |                Tables                 |
 +---------------------------------------+
 | CHARACTER_SETS                        |
+| CLIENT_STATISTICS                     |
 | COLLATIONS                            |
 | COLLATION_CHARACTER_SET_APPLICABILITY |
 | COLUMNS                               |
@@ -89,6 +90,7 @@ Database: information_schema
 | FILES                                 |
 | GLOBAL_STATUS                         |
 | GLOBAL_VARIABLES                      |
+| INDEX_STATISTICS                      |
 | KEY_COLUMN_USAGE                      |
 | PARTITIONS                            |
 | PLUGINS                               |
@@ -104,8 +106,10 @@ Database: information_schema
 | TABLES                                |
 | TABLE_CONSTRAINTS                     |
 | TABLE_PRIVILEGES                      |
+| TABLE_STATISTICS                      |
 | TRIGGERS                              |
 | USER_PRIVILEGES                       |
+| USER_STATISTICS                       |
 | VIEWS                                 |
 +---------------------------------------+
 Database: INFORMATION_SCHEMA
@@ -113,6 +117,7 @@ Database: INFORMATION_SCHEMA
 |                Tables                 |
 +---------------------------------------+
 | CHARACTER_SETS                        |
+| CLIENT_STATISTICS                     |
 | COLLATIONS                            |
 | COLLATION_CHARACTER_SET_APPLICABILITY |
 | COLUMNS                               |
@@ -122,6 +127,7 @@ Database: INFORMATION_SCHEMA
 | FILES                                 |
 | GLOBAL_STATUS                         |
 | GLOBAL_VARIABLES                      |
+| INDEX_STATISTICS                      |
 | KEY_COLUMN_USAGE                      |
 | PARTITIONS                            |
 | PLUGINS                               |
@@ -137,8 +143,10 @@ Database: INFORMATION_SCHEMA
 | TABLES                                |
 | TABLE_CONSTRAINTS                     |
 | TABLE_PRIVILEGES                      |
+| TABLE_STATISTICS                      |
 | TRIGGERS                              |
 | USER_PRIVILEGES                       |
+| USER_STATISTICS                       |
 | VIEWS                                 |
 +---------------------------------------+
 Wildcard: inf_rmation_schema
diff --git a/sql/handler.cc b/sql/handler.cc
index 4f5c613..3d57b4a 100644
--- a/sql/handler.cc
+++ b/sql/handler.cc
@@ -1241,6 +1241,7 @@ int ha_commit_one_phase(THD *thd, bool all)
         error=1;
       }
       status_var_increment(thd->status_var.ha_commit_count);
+      thd->diff_commit_trans++;
       ha_info_next= ha_info->next();
       ha_info->reset(); /* keep it conveniently zero-filled */
     }
@@ -1315,6 +1316,7 @@ int ha_rollback_trans(THD *thd, bool all)
         error=1;
       }
       status_var_increment(thd->status_var.ha_rollback_count);
+      thd->diff_rollback_trans++;
       ha_info_next= ha_info->next();
       ha_info->reset(); /* keep it conveniently zero-filled */
     }
@@ -1326,6 +1328,7 @@ int ha_rollback_trans(THD *thd, bool all)
     if (all)
       thd->variables.tx_isolation=thd->session_tx_isolation;
   }
+  thd->diff_rollback_trans++;
   /* Always cleanup. Even if there nht==0. There may be savepoints. */
   if (is_real_trans)
     thd->transaction.cleanup();
@@ -1764,10 +1767,12 @@ int ha_rollback_to_savepoint(THD *thd, SAVEPOINT *sv)
       error=1;
     }
     status_var_increment(thd->status_var.ha_rollback_count);
+    thd->diff_rollback_trans++;
     ha_info_next= ha_info->next();
     ha_info->reset(); /* keep it conveniently zero-filled */
   }
   trans->ha_list= sv->ha_list;
+  thd->diff_rollback_trans++;
   DBUG_RETURN(error);
 }
 
@@ -2135,6 +2140,8 @@ int handler::ha_open(TABLE *table_arg, const char *name, int mode,
       dup_ref=ref+ALIGN_SIZE(ref_length);
     cached_table_flags= table_flags();
   }
+  rows_read = rows_changed = 0;
+  memset(index_rows_read, 0, sizeof(index_rows_read));
   DBUG_RETURN(error);
 }
 
@@ -3616,6 +3623,98 @@ void handler::get_dynamic_partition_info(PARTITION_INFO *stat_info,
   return;
 }
 
+// Updates the global table stats with the TABLE this handler represents.
+void handler::update_global_table_stats() {
+  if (!rows_read && !rows_changed) return;  // Nothing to update.
+  // table_cache_key is db_name + '\0' + table_name + '\0'.
+  if (!table->s || !table->s->table_cache_key.str || !table->s->table_name.str) return;
+
+   TABLE_STATS* table_stats;
+  char key[NAME_LEN * 2 + 2];
+  // [db] + '.' + [table]
+  sprintf(key, "%s.%s", table->s->table_cache_key.str, table->s->table_name.str);
+
+  pthread_mutex_lock(&LOCK_global_table_stats);
+  // Gets the global table stats, creating one if necessary.
+  if (!(table_stats = (TABLE_STATS*)hash_search(&global_table_stats,
+                                                (uchar*)key,
+                                                strlen(key)))) {
+    if (!(table_stats = ((TABLE_STATS*)
+                         my_malloc(sizeof(TABLE_STATS), MYF(MY_WME))))) {
+      // Out of memory.
+      sql_print_error("Allocating table stats failed.");
+      goto end;
+    }
+    strncpy(table_stats->table, key, sizeof(table_stats->table));
+    table_stats->rows_read = 0;
+    table_stats->rows_changed = 0;
+    table_stats->rows_changed_x_indexes = 0;
+    table_stats->engine_type = (int) ht->db_type;
+
+    if (my_hash_insert(&global_table_stats, (uchar*)table_stats)) {
+      // Out of memory.
+      sql_print_error("Inserting table stats failed.");
+      my_free((char*)table_stats, 0);
+      goto end;
+    }
+  }
+  // Updates the global table stats.
+  table_stats->rows_read += rows_read;
+  table_stats->rows_changed += rows_changed;
+  table_stats->rows_changed_x_indexes +=
+      rows_changed * (table->s->keys ? table->s->keys : 1);
+  rows_read = rows_changed = 0;
+end:
+  pthread_mutex_unlock(&LOCK_global_table_stats);
+}
+
+// Updates the global index stats with this handler's accumulated index reads.
+void handler::update_global_index_stats() {
+  // table_cache_key is db_name + '\0' + table_name + '\0'.
+  if (!table->s || !table->s->table_cache_key.str || !table->s->table_name.str) return;
+
+  for (uint x = 0; x < table->s->keys; x++) {
+    if (index_rows_read[x]) {
+      // Rows were read using this index.
+      KEY* key_info = &table->key_info[x];
+
+      if (!key_info->name) continue;
+
+      INDEX_STATS* index_stats;
+      char key[NAME_LEN * 3 + 3];
+      // [db] + '.' + [table] + '.' + [index]
+      sprintf(key, "%s.%s.%s",  table->s->table_cache_key.str,
+              table->s->table_name.str, key_info->name);
+
+      pthread_mutex_lock(&LOCK_global_index_stats);
+      // Gets the global index stats, creating one if necessary.
+      if (!(index_stats = (INDEX_STATS*)hash_search(&global_index_stats,
+                                                    (uchar*)key,
+                                                    strlen(key)))) {
+        if (!(index_stats = ((INDEX_STATS*)
+                                   +                             my_malloc(sizeof(INDEX_STATS), MYF(MY_WME))))) {
+          // Out of memory.
+          sql_print_error("Allocating index stats failed.");
+          goto end;
+        }
+        strncpy(index_stats->index, key, sizeof(index_stats->index));
+        index_stats->rows_read = 0;
+
+        if (my_hash_insert(&global_index_stats, (uchar*)index_stats)) {
+          // Out of memory.
+          sql_print_error("Inserting index stats failed.");
+          my_free((char*)index_stats, 0);
+          goto end;
+        }
+      }
+      // Updates the global index stats.
+      index_stats->rows_read += index_rows_read[x];
+      index_rows_read[x] = 0;
+end:
+      pthread_mutex_unlock(&LOCK_global_index_stats);
+    }
+  }
+}
 
 /****************************************************************************
 ** Some general functions that isn't in the handler class
diff --git a/sql/handler.h b/sql/handler.h
index c9943fd..0a0bde2 100644
--- a/sql/handler.h
+++ b/sql/handler.h
@@ -31,6 +31,10 @@
 
 #define USING_TRANSACTIONS
 
+#if MAX_KEY > 128
+#error MAX_KEY is too large.  Values up to 128 are supported.
+#endif
+
 // the following is for checking tables
 
 #define HA_ADMIN_ALREADY_DONE	  1
@@ -1152,6 +1156,11 @@ public:
   */
   uint auto_inc_intervals_count;
 
+   ulonglong rows_read;
+   ulonglong rows_changed;
+   ulonglong index_rows_read[MAX_KEY];
+
+
   handler(handlerton *ht_arg, TABLE_SHARE *share_arg)
     :table_share(share_arg), table(0),
     estimation_rows_to_insert(0), ht(ht_arg),
@@ -1160,8 +1169,12 @@ public:
     ft_handler(0), inited(NONE),
     locked(FALSE), implicit_emptied(0),
     pushed_cond(0), next_insert_id(0), insert_id_for_cur_row(0),
-    auto_inc_intervals_count(0)
-    {}
+    auto_inc_intervals_count(0),
+    rows_read(0), rows_changed(0)
+    {
+      memset(index_rows_read, 0, sizeof(index_rows_read));
+    }
+
   virtual ~handler(void)
   {
     DBUG_ASSERT(locked == FALSE);
@@ -1285,7 +1298,13 @@ public:
   {
     table= table_arg;
     table_share= share;
+    rows_read = rows_changed = 0;
+    memset(index_rows_read, 0, sizeof(index_rows_read));
   }
+
+  void update_global_table_stats();
+  void update_global_index_stats();
+
   virtual double scan_time()
   { return ulonglong2double(stats.data_file_length) / IO_SIZE + 2; }
   virtual double read_time(uint index, uint ranges, ha_rows rows)
diff --git a/sql/item_func.cc b/sql/item_func.cc
index feb87fe..2b8d71b 100644
--- a/sql/item_func.cc
+++ b/sql/item_func.cc
@@ -3397,7 +3397,6 @@ longlong Item_master_pos_wait::val_int()
   return event_count;
 }
 
-
 /**
   Get a user level lock.  If the thread has an old lock this is first released.
 
diff --git a/sql/lex.h b/sql/lex.h
index 87264a3..e90ee68 100644
--- a/sql/lex.h
+++ b/sql/lex.h
@@ -109,6 +109,7 @@ static SYMBOL symbols[] = {
   { "CHECKSUM",		SYM(CHECKSUM_SYM)},
   { "CIPHER",		SYM(CIPHER_SYM)},
   { "CLIENT",		SYM(CLIENT_SYM)},
+  { "CLIENT_STATISTICS",	SYM(CLIENT_STATS_SYM)},
   { "CLOSE",		SYM(CLOSE_SYM)},
   { "COALESCE",		SYM(COALESCE)},
   { "CODE",             SYM(CODE_SYM)},
@@ -248,6 +249,7 @@ static SYMBOL symbols[] = {
   { "IN",		SYM(IN_SYM)},
   { "INDEX",		SYM(INDEX_SYM)},
   { "INDEXES",		SYM(INDEXES)},
+  { "INDEX_STATISTICS",	SYM(INDEX_STATS_SYM)},
   { "INFILE",		SYM(INFILE)},
   { "INITIAL_SIZE",	SYM(INITIAL_SIZE_SYM)},
   { "INNER",		SYM(INNER_SYM)},
@@ -480,6 +482,7 @@ static SYMBOL symbols[] = {
   { "SIGNED",		SYM(SIGNED_SYM)},
   { "SIMPLE",		SYM(SIMPLE_SYM)},
   { "SLAVE",            SYM(SLAVE)},
+  { "SLOW",             SYM(SLOW_SYM)},
   { "SNAPSHOT",         SYM(SNAPSHOT_SYM)},
   { "SMALLINT",		SYM(SMALLINT)},
   { "SOCKET",		SYM(SOCKET_SYM)},
@@ -529,6 +532,7 @@ static SYMBOL symbols[] = {
   { "TABLES",		SYM(TABLES)},
   { "TABLESPACE",	        SYM(TABLESPACE)},
   { "TABLE_CHECKSUM",	SYM(TABLE_CHECKSUM_SYM)},
+  { "TABLE_STATISTICS",	SYM(TABLE_STATS_SYM)},
   { "TEMPORARY",	SYM(TEMPORARY)},
   { "TEMPTABLE",	SYM(TEMPTABLE_SYM)},
   { "TERMINATED",	SYM(TERMINATED)},
@@ -570,6 +574,7 @@ static SYMBOL symbols[] = {
   { "USE",		SYM(USE_SYM)},
   { "USER",		SYM(USER)},
   { "USER_RESOURCES",	SYM(RESOURCES)},
+  { "USER_STATISTICS", SYM(USER_STATS_SYM)},
   { "USE_FRM",		SYM(USE_FRM)},
   { "USING",		SYM(USING)},
   { "UTC_DATE",         SYM(UTC_DATE_SYM)},
diff --git a/sql/log.cc b/sql/log.cc
index 57c14b2..b7e3851 100644
--- a/sql/log.cc
+++ b/sql/log.cc
@@ -824,6 +824,13 @@ void Log_to_file_event_handler::flush()
     mysql_slow_log.reopen_file();
 }
 
+void Log_to_file_event_handler::flush_slow_log()
+{
+  /* reopen slow log file */
+  if (opt_slow_log)
+    mysql_slow_log.reopen_file();
+}
+
 /*
   Log error with all enabled log event handlers
 
@@ -935,6 +942,23 @@ bool LOGGER::flush_logs(THD *thd)
   return rc;
 }
 
+bool LOGGER::flush_slow_log(THD *thd)
+{
+  int rc= 0;
+
+  /*
+    Now we lock logger, as nobody should be able to use logging routines while
+    log tables are closed
+  */
+  logger.lock_exclusive();
+
+  /* reopen log files */
+  file_log_handler->flush_slow_log();
+
+  /* end of log flush */
+  logger.unlock();
+  return rc;
+}
 
 /*
   Log slow query with all enabled log event handlers
@@ -4474,6 +4498,8 @@ bool MYSQL_BIN_LOG::write(Log_event *event_info)
                              thd->first_successful_insert_id_in_prev_stmt_for_binlog);
           if (e.write(file))
             goto err;
+          if (file == &log_file)
+            thd->binlog_bytes_written += e.data_written;
         }
         if (thd->auto_inc_intervals_in_cur_stmt_for_binlog.nb_elements() > 0)
         {
@@ -4485,12 +4511,16 @@ bool MYSQL_BIN_LOG::write(Log_event *event_info)
                              minimum());
           if (e.write(file))
             goto err;
+          if (file == &log_file)
+            thd->binlog_bytes_written += e.data_written;
         }
         if (thd->rand_used)
         {
           Rand_log_event e(thd,thd->rand_saved_seed1,thd->rand_saved_seed2);
           if (e.write(file))
             goto err;
+          if (file == &log_file)
+            thd->binlog_bytes_written += e.data_written;
         }
         if (thd->user_var_events.elements)
         {
@@ -4506,6 +4536,8 @@ bool MYSQL_BIN_LOG::write(Log_event *event_info)
                                  user_var_event->charset_number);
             if (e.write(file))
               goto err;
+            if (file == &log_file)
+              thd->binlog_bytes_written += e.data_written;
           }
         }
       }
@@ -4518,6 +4550,8 @@ bool MYSQL_BIN_LOG::write(Log_event *event_info)
     if (event_info->write(file) || 
         DBUG_EVALUATE_IF("injecting_fault_writing", 1, 0))
       goto err;
+    if (file == &log_file)
+      thd->binlog_bytes_written += event_info->data_written;
 
     if (file == &log_file) // we are writing to the real log (disk)
     {
@@ -4679,6 +4713,7 @@ uint MYSQL_BIN_LOG::next_file_id()
 
   SYNOPSIS
     write_cache()
+    thd      Current thread
     cache    Cache to write to the binary log
     lock_log True if the LOCK_log mutex should be aquired, false otherwise
     sync_log True if the log should be flushed and sync:ed
@@ -4688,7 +4723,7 @@ uint MYSQL_BIN_LOG::next_file_id()
     be reset as a READ_CACHE to be able to read the contents from it.
  */
 
-int MYSQL_BIN_LOG::write_cache(IO_CACHE *cache, bool lock_log, bool sync_log)
+int MYSQL_BIN_LOG::write_cache(THD *thd, IO_CACHE *cache, bool lock_log, bool sync_log)
 {
   Mutex_sentry sentry(lock_log ? &LOCK_log : NULL);
 
@@ -4736,6 +4771,7 @@ int MYSQL_BIN_LOG::write_cache(IO_CACHE *cache, bool lock_log, bool sync_log)
       /* write the first half of the split header */
       if (my_b_write(&log_file, header, carry))
         return ER_ERROR_ON_WRITE;
+      thd->binlog_bytes_written += carry;
 
       /*
         copy fixed second half of header to cache so the correct
@@ -4804,6 +4840,8 @@ int MYSQL_BIN_LOG::write_cache(IO_CACHE *cache, bool lock_log, bool sync_log)
     /* Write data to the binary log file */
     if (my_b_write(&log_file, cache->read_pos, length))
       return ER_ERROR_ON_WRITE;
+    thd->binlog_bytes_written += length;
+
     cache->read_pos=cache->read_end;		// Mark buffer used up
   } while ((length= my_b_fill(cache)));
 
@@ -4930,17 +4968,18 @@ bool MYSQL_BIN_LOG::write(THD *thd, IO_CACHE *cache, Log_event *commit_event,
       */
       if (qinfo.write(&log_file))
         goto err;
+      thd->binlog_bytes_written += qinfo.data_written;
 
       DBUG_EXECUTE_IF("crash_before_writing_xid",
                       {
-                        if ((write_error= write_cache(cache, false, true)))
+                        if ((write_error= write_cache(thd,cache, false, true)))
                           DBUG_PRINT("info", ("error writing binlog cache: %d",
                                                write_error));
                         DBUG_PRINT("info", ("crashing before writing xid"));
                         DBUG_SUICIDE();
                       });
 
-      if ((write_error= write_cache(cache, false, false)))
+      if ((write_error= write_cache(thd, cache, false, false)))
         goto err;
 
       if (commit_event && commit_event->write(&log_file))
@@ -4948,6 +4987,7 @@ bool MYSQL_BIN_LOG::write(THD *thd, IO_CACHE *cache, Log_event *commit_event,
 
       if (incident && write_incident(thd, FALSE))
         goto err;
+      thd->binlog_bytes_written += commit_event->data_written;
 
       if (flush_and_sync())
         goto err;
diff --git a/sql/log.h b/sql/log.h
index 02721f1..1c60da8 100644
--- a/sql/log.h
+++ b/sql/log.h
@@ -368,7 +368,7 @@ public:
   bool write(THD *thd, IO_CACHE *cache, Log_event *commit_event, bool incident);
 
   bool write_incident(THD *thd, bool lock);
-  int  write_cache(IO_CACHE *cache, bool lock_log, bool flush_and_sync);
+  int  write_cache(THD *thd, IO_CACHE *cache, bool lock_log, bool flush_and_sync);
   void set_write_error(THD *thd);
   bool check_write_error(THD *thd);
 
@@ -506,6 +506,7 @@ public:
                            const char *sql_text, uint sql_text_len,
                            CHARSET_INFO *client_cs);
   void flush();
+  void flush_slow_log();
   void init_pthread_objects();
   MYSQL_QUERY_LOG *get_mysql_slow_log() { return &mysql_slow_log; }
   MYSQL_QUERY_LOG *get_mysql_log() { return &mysql_log; }
@@ -550,6 +551,7 @@ public:
   void init_base();
   void init_log_tables();
   bool flush_logs(THD *thd);
+  bool flush_slow_log(THD *thd);
   /* Perform basic logger cleanup. this will leave e.g. error log open. */
   void cleanup_base();
   /* Free memory. Nothing could be logged after this function is called */
diff --git a/sql/mysql_priv.h b/sql/mysql_priv.h
index 9376170..ddbd59c 100644
--- a/sql/mysql_priv.h
+++ b/sql/mysql_priv.h
@@ -48,6 +48,8 @@
 
 class Parser_state;
 
+class MYSQL_QUERY_LOG;
+
 /**
   Query type constants.
 
@@ -136,7 +138,6 @@ extern MYSQL_PLUGIN_IMPORT CHARSET_INFO *files_charset_info ;
 extern MYSQL_PLUGIN_IMPORT CHARSET_INFO *national_charset_info;
 extern MYSQL_PLUGIN_IMPORT CHARSET_INFO *table_alias_charset;
 
-
 enum Derivation
 {
   DERIVATION_IGNORABLE= 5,
@@ -607,6 +608,20 @@ protected:
 
 /* Used to check GROUP BY list in the MODE_ONLY_FULL_GROUP_BY mode */
 #define UNDEF_POS (-1)
+#ifdef EXTRA_DEBUG
+/**
+  Sync points allow us to force the server to reach a certain line of code
+  and block there until the client tells the server it is ok to go on.
+  The client tells the server to block with SELECT GET_LOCK()
+  and unblocks it with SELECT RELEASE_LOCK(). Used for debugging difficult
+  concurrency problems
+*/
+#define DBUG_SYNC_POINT(lock_name,lock_timeout) \
+ debug_sync_point(lock_name,lock_timeout)
+void debug_sync_point(const char* lock_name, uint lock_timeout);
+#else
+#define DBUG_SYNC_POINT(lock_name,lock_timeout)
+#endif /* EXTRA_DEBUG */
 
 /* BINLOG_DUMP options */
 
@@ -1074,7 +1089,21 @@ void mysql_init_multi_delete(LEX *lex);
 bool multi_delete_set_locks_and_link_aux_tables(LEX *lex);
 void init_max_user_conn(void);
 void init_update_queries(void);
+void init_global_user_stats(void);
+void init_global_table_stats(void);
+void init_global_index_stats(void);
+void init_global_client_stats(void);
 void free_max_user_conn(void);
+void free_global_user_stats(void);
+void free_global_table_stats(void);
+void free_global_index_stats(void);
+void free_global_client_stats(void);
+// Uses the THD to update the global stats.
+void update_global_user_stats(THD* thd, bool create_user, time_t now);
+// Set stats for concurrent connections displayed by mysqld_show().
+void set_concurrent_connections_stats();
+// Increments connection count for user.
+int increment_connection_count(THD* thd, bool use_lock);
 pthread_handler_t handle_bootstrap(void *arg);
 int mysql_execute_command(THD *thd);
 bool do_command(THD *thd);
@@ -1787,11 +1816,11 @@ int write_record(THD *thd, TABLE *table, COPY_INFO *info);
 
 /* sql_manager.cc */
 extern bool volatile  mqh_used;
+
 void start_handle_manager();
 void stop_handle_manager();
 bool mysql_manager_submit(void (*action)());
 
-
 /* sql_test.cc */
 #ifndef DBUG_OFF
 void print_where(COND *cond,const char *info, enum_query_type query_type);
@@ -1942,6 +1971,7 @@ extern MYSQL_PLUGIN_IMPORT ulong max_connections;
 extern ulong max_connect_errors, connect_timeout;
 extern ulong slave_net_timeout, slave_trans_retries;
 extern uint max_user_connections;
+extern ulonglong denied_connections;
 extern ulong what_to_log,flush_time;
 extern ulong query_buff_size;
 extern ulong slave_max_allowed_packet;
@@ -1962,6 +1992,7 @@ extern ulong expire_logs_days, sync_binlog_period, sync_binlog_counter;
 extern ulong opt_tc_log_size, tc_log_max_pages_used, tc_log_page_size;
 extern ulong tc_log_page_waits;
 extern my_bool relay_log_purge, opt_innodb_safe_binlog, opt_innodb;
+
 extern uint test_flags,select_errors,ha_open_options;
 extern uint protocol_version, mysqld_port, dropping_tables;
 extern uint delay_key_write_options;
@@ -1988,7 +2019,7 @@ extern bool opt_disable_networking, opt_skip_show_db;
 extern bool opt_skip_name_resolve;
 extern bool opt_ignore_builtin_innodb;
 extern my_bool opt_character_set_client_handshake;
-extern bool volatile abort_loop, shutdown_in_progress;
+extern bool volatile abort_loop, shutdown_in_progress, grant_option;
 extern bool in_bootstrap;
 extern uint volatile thread_count, thread_running, global_read_lock;
 extern uint connection_count;
@@ -2017,6 +2048,7 @@ extern char *opt_logname, *opt_slow_logname;
 extern const char *log_output_str;
 
 extern MYSQL_PLUGIN_IMPORT MYSQL_BIN_LOG mysql_bin_log;
+extern MYSQL_QUERY_LOG mysql_slow_log;
 extern LOGGER logger;
 extern TABLE_LIST general_log, slow_log;
 extern FILE *bootstrap_file;
@@ -2061,6 +2093,14 @@ extern MYSQL_PLUGIN_IMPORT struct system_variables global_system_variables;
 extern struct system_variables max_system_variables;
 extern struct system_status_var global_status_var;
 extern struct rand_struct sql_rand;
+extern HASH global_user_stats;
+extern HASH global_client_stats;
+extern pthread_mutex_t LOCK_global_user_client_stats;
+extern HASH global_table_stats;
+extern pthread_mutex_t LOCK_global_table_stats;
+extern HASH global_index_stats;
+extern pthread_mutex_t LOCK_global_index_stats;
+extern pthread_mutex_t LOCK_stats;
 
 extern const char *opt_date_time_formats[];
 extern KNOWN_DATE_TIME_FORMAT known_date_time_formats[];
@@ -2545,6 +2585,7 @@ bool load_collation(MEM_ROOT *mem_root,
                     CHARSET_INFO *dflt_cl,
                     CHARSET_INFO **cl);
 
+
 #endif /* MYSQL_SERVER */
 extern "C" int test_if_data_home_dir(const char *dir);
 
diff --git a/sql/mysqld.cc b/sql/mysqld.cc
index bc8d416..e13039a 100644
--- a/sql/mysqld.cc
+++ b/sql/mysqld.cc
@@ -495,6 +495,8 @@ my_bool opt_local_infile, opt_slave_compressed_protocol;
 my_bool opt_safe_user_create = 0, opt_no_mix_types = 0;
 my_bool opt_show_slave_auth_info, opt_sql_bin_update = 0;
 my_bool opt_log_slave_updates= 0;
+ulonglong denied_connections= 0;
+
 bool slave_warning_issued = false; 
 
 /*
@@ -693,6 +695,11 @@ pthread_mutex_t LOCK_mysql_create_db, LOCK_Acl, LOCK_open, LOCK_thread_count,
 	        LOCK_global_system_variables,
 		LOCK_user_conn, LOCK_slave_list, LOCK_active_mi,
                 LOCK_connection_count;
+pthread_mutex_t LOCK_stats;
+pthread_mutex_t LOCK_global_user_client_stats;
+pthread_mutex_t LOCK_global_table_stats;
+pthread_mutex_t LOCK_global_index_stats;
+
 /**
   The below lock protects access to two global server variables:
   max_prepared_stmt_count and prepared_stmt_count. These variables
@@ -874,8 +881,8 @@ static void clean_up_mutexes(void);
 static void wait_for_signal_thread_to_end(void);
 static void create_pid_file();
 static void end_ssl();
-#endif
 
+#endif
 
 #ifndef EMBEDDED_LIBRARY
 /****************************************************************************
@@ -884,9 +891,6 @@ static void end_ssl();
 
 static void close_connections(void)
 {
-#ifdef EXTRA_DEBUG
-  int count=0;
-#endif
   DBUG_ENTER("close_connections");
 
   /* Clear thread cache */
@@ -918,10 +922,6 @@ static void close_connections(void)
       if (error != EINTR)
 	break;
     }
-#ifdef EXTRA_DEBUG
-    if (error != 0 && !count++)
-      sql_print_error("Got error %d from pthread_cond_timedwait",error);
-#endif
     close_server_sock();
   }
   (void) pthread_mutex_unlock(&LOCK_thread_count);
@@ -1378,6 +1378,11 @@ void clean_up(bool print_message)
   x_free(opt_secure_file_priv);
   bitmap_free(&temp_pool);
   free_max_user_conn();
+  free_global_user_stats();
+  free_global_client_stats();
+  free_global_table_stats();
+  free_global_index_stats();
+
 #ifdef HAVE_REPLICATION
   end_slave_list();
 #endif
@@ -1494,6 +1499,10 @@ static void clean_up_mutexes()
   (void) pthread_cond_destroy(&COND_thread_cache);
   (void) pthread_cond_destroy(&COND_flush_thread_cache);
   (void) pthread_cond_destroy(&COND_manager);
+  (void) pthread_mutex_destroy(&LOCK_stats);
+  (void) pthread_mutex_destroy(&LOCK_global_user_client_stats);
+  (void) pthread_mutex_destroy(&LOCK_global_table_stats);
+  (void) pthread_mutex_destroy(&LOCK_global_index_stats);
 }
 
 #endif /*EMBEDDED_LIBRARY*/
@@ -2678,9 +2687,6 @@ pthread_handler_t signal_hand(void *arg __attribute__((unused)))
     case SIGTERM:
     case SIGQUIT:
     case SIGKILL:
-#ifdef EXTRA_DEBUG
-      sql_print_information("Got signal %d to shutdown mysqld",sig);
-#endif
       /* switch to the old log message processing */
       logger.set_handlers(LOG_FILE, opt_slow_log ? LOG_FILE:LOG_NONE,
                           opt_log ? LOG_FILE:LOG_NONE);
@@ -2731,9 +2737,6 @@ pthread_handler_t signal_hand(void *arg __attribute__((unused)))
       break;
 #endif
     default:
-#ifdef EXTRA_DEBUG
-      sql_print_warning("Got signal: %d  error: %d",sig,error); /* purecov: tested */
-#endif
       break;					/* purecov: tested */
     }
   }
@@ -3037,6 +3040,7 @@ SHOW_VAR com_status_vars[]= {
   {"show_binlog_events",   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_BINLOG_EVENTS]), SHOW_LONG_STATUS},
   {"show_binlogs",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_BINLOGS]), SHOW_LONG_STATUS},
   {"show_charsets",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CHARSETS]), SHOW_LONG_STATUS},
+  {"show_client_stats",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CLIENT_STATS]), SHOW_LONG_STATUS},
   {"show_collations",      (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_COLLATIONS]), SHOW_LONG_STATUS},
   {"show_column_types",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_COLUMN_TYPES]), SHOW_LONG_STATUS},
   {"show_contributors",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_CONTRIBUTORS]), SHOW_LONG_STATUS},
@@ -3059,6 +3063,7 @@ SHOW_VAR com_status_vars[]= {
   {"show_function_status", (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_STATUS_FUNC]), SHOW_LONG_STATUS},
   {"show_grants",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_GRANTS]), SHOW_LONG_STATUS},
   {"show_keys",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_KEYS]), SHOW_LONG_STATUS},
+  {"show_index_stats",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_INDEX_STATS]), SHOW_LONG_STATUS},
   {"show_master_status",   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_MASTER_STAT]), SHOW_LONG_STATUS},
   {"show_new_master",      (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_NEW_MASTER]), SHOW_LONG_STATUS},
   {"show_open_tables",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_OPEN_TABLES]), SHOW_LONG_STATUS},
@@ -3075,9 +3080,11 @@ SHOW_VAR com_status_vars[]= {
   {"show_slave_status",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_SLAVE_STAT]), SHOW_LONG_STATUS},
   {"show_status",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_STATUS]), SHOW_LONG_STATUS},
   {"show_storage_engines", (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_STORAGE_ENGINES]), SHOW_LONG_STATUS},
+  {"show_table_stats",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_TABLE_STATS]), SHOW_LONG_STATUS},
   {"show_table_status",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_TABLE_STATUS]), SHOW_LONG_STATUS},
   {"show_tables",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_TABLES]), SHOW_LONG_STATUS},
   {"show_triggers",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_TRIGGERS]), SHOW_LONG_STATUS},
+  {"show_user_stats",      (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_USER_STATS]), SHOW_LONG_STATUS},
   {"show_variables",       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_VARIABLES]), SHOW_LONG_STATUS},
   {"show_warnings",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_WARNS]), SHOW_LONG_STATUS},
   {"slave_start",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SLAVE_START]), SHOW_LONG_STATUS},
@@ -3521,6 +3528,10 @@ static int init_thread_environment()
 #endif
   (void) pthread_mutex_init(&LOCK_server_started, MY_MUTEX_INIT_FAST);
   (void) pthread_cond_init(&COND_server_started,NULL);
+  (void) pthread_mutex_init(&LOCK_stats, MY_MUTEX_INIT_FAST);
+  (void) pthread_mutex_init(&LOCK_global_user_client_stats, MY_MUTEX_INIT_FAST);
+  (void) pthread_mutex_init(&LOCK_global_table_stats, MY_MUTEX_INIT_FAST);
+  (void) pthread_mutex_init(&LOCK_global_index_stats, MY_MUTEX_INIT_FAST);
   sp_cache_init();
 #ifdef HAVE_EVENT_SCHEDULER
   Events::init_mutexes();
@@ -3922,6 +3933,9 @@ a file name for --log-bin-index option", opt_binlog_index_name);
   if (!errmesg[0][0])
     unireg_abort(1);
 
+   init_global_table_stats();
+   init_global_index_stats();
+
   /* We have to initialize the storage engines before CSV logging */
   if (ha_init())
   {
@@ -4068,6 +4082,9 @@ a file name for --log-bin-index option", opt_binlog_index_name);
 
   init_max_user_conn();
   init_update_queries();
+  init_global_user_stats();
+  init_global_client_stats();
+
   DBUG_RETURN(0);
 }
 
@@ -4332,21 +4349,6 @@ int main(int argc, char **argv)
   if (opt_bin_log && !server_id)
   {
     server_id= !master_host ? 1 : 2;
-#ifdef EXTRA_DEBUG
-    switch (server_id) {
-    case 1:
-      sql_print_warning("\
-You have enabled the binary log, but you haven't set server-id to \
-a non-zero value: we force server id to 1; updates will be logged to the \
-binary log, but connections from slaves will not be accepted.");
-      break;
-    case 2:
-      sql_print_warning("\
-You should set server-id to a non-0 value if master_host is set; \
-we force server id to 2, but this MySQL server will not act as a slave.");
-      break;
-    }
-#endif
   }
 
   if (init_server_components())
@@ -4475,17 +4477,11 @@ we force server id to 2, but this MySQL server will not act as a slave.");
   DBUG_PRINT("quit",("Exiting main thread"));
 
 #ifndef __WIN__
-#ifdef EXTRA_DEBUG2
-  sql_print_error("Before Lock_thread_count");
-#endif
   (void) pthread_mutex_lock(&LOCK_thread_count);
   DBUG_PRINT("quit", ("Got thread_count mutex"));
   select_thread_in_use=0;			// For close_connections
   (void) pthread_mutex_unlock(&LOCK_thread_count);
   (void) pthread_cond_broadcast(&COND_thread_count);
-#ifdef EXTRA_DEBUG2
-  sql_print_error("After lock_thread_count");
-#endif
 #endif /* __WIN__ */
 
   /* Wait until cleanup is done */
@@ -4889,6 +4885,7 @@ static void create_new_thread(THD *thd)
 
     DBUG_PRINT("error",("Too many connections"));
     close_connection(thd, ER_CON_COUNT_ERROR, 1);
+    statistic_increment(denied_connections, &LOCK_status);
     delete thd;
     DBUG_VOID_RETURN;
   }
@@ -7190,7 +7187,7 @@ static int show_slave_running(THD *thd, SHOW_VAR *var, char *buff)
   pthread_mutex_lock(&LOCK_active_mi);
   var->value= buff;
   *((my_bool *)buff)= (my_bool) (active_mi && 
-                                 active_mi->slave_running == MYSQL_SLAVE_RUN_CONNECT &&
+                                 active_mi->slave_running == MYSQL_SLAVE_RUN_CONNECT && 
                                  active_mi->rli.slave_running);
   pthread_mutex_unlock(&LOCK_active_mi);
   return 0;
diff --git a/sql/set_var.cc b/sql/set_var.cc
index bbc47c2..b2c5c30 100644
--- a/sql/set_var.cc
+++ b/sql/set_var.cc
@@ -179,7 +179,7 @@ static sys_var_bool_ptr	sys_automatic_sp_privileges(&vars, "automatic_sp_privile
 static sys_var_const            sys_back_log(&vars, "back_log",
                                              OPT_GLOBAL, SHOW_LONG,
                                              (uchar*) &back_log);
-static sys_var_const_os_str       sys_basedir(&vars, "basedir", mysql_home);
+static sys_var_const_os_str    sys_basedir(&vars, "basedir", mysql_home);
 static sys_var_long_ptr	sys_binlog_cache_size(&vars, "binlog_cache_size",
 					      &binlog_cache_size);
 static sys_var_thd_binlog_format sys_binlog_format(&vars, "binlog_format",
@@ -668,7 +668,9 @@ static sys_var_bool_ptr  sys_timed_mutexes(&vars, "timed_mutexes",
                                     &timed_mutexes);
 static sys_var_const_str	sys_version(&vars, "version", server_version);
 static sys_var_const_str	sys_version_comment(&vars, "version_comment",
-                                            MYSQL_COMPILATION_COMMENT);
+                                                    MYSQL_COMPILATION_COMMENT
+                                                    " (Cloud Linux "
+                                                    __DATE__ " " __TIME__ ")");
 static sys_var_const_str	sys_version_compile_machine(&vars, "version_compile_machine",
                                                     MACHINE_TYPE);
 static sys_var_const_str	sys_version_compile_os(&vars, "version_compile_os",
@@ -923,7 +925,6 @@ static sys_var_readonly         sys_myisam_mmap_size(&vars, "myisam_mmap_size",
                                                      SHOW_LONGLONG,
                                                      get_myisam_mmap_size);
 
-
 bool sys_var::check(THD *thd, set_var *var)
 {
   var->save_result.ulonglong_value= var->value->val_int();
diff --git a/sql/sql_base.cc b/sql/sql_base.cc
index 2ce5ec8..21cf0f2 100644
--- a/sql/sql_base.cc
+++ b/sql/sql_base.cc
@@ -1391,6 +1391,12 @@ bool close_thread_table(THD *thd, TABLE **table_ptr)
   DBUG_PRINT("tcache", ("table: '%s'.'%s' 0x%lx", table->s->db.str,
                         table->s->table_name.str, (long) table));
 
+  if(table->file)
+  {
+    table->file->update_global_table_stats();
+    table->file->update_global_index_stats();
+  }
+
   *table_ptr=table->next;
   /*
     When closing a MERGE parent or child table, detach the children first.
@@ -1930,6 +1936,9 @@ void close_temporary(TABLE *table, bool free_share, bool delete_table)
   DBUG_ENTER("close_temporary");
   DBUG_PRINT("tmptable", ("closing table: '%s'.'%s'",
                           table->s->db.str, table->s->table_name.str));
+ 
+  table->file->update_global_table_stats();
+  table->file->update_global_index_stats();
 
   free_io_cache(table);
   closefrm(table, 0);
diff --git a/sql/sql_class.cc b/sql/sql_class.cc
index 0f6bd4c..b93753a 100644
--- a/sql/sql_class.cc
+++ b/sql/sql_class.cc
@@ -675,6 +675,13 @@ THD::THD()
   bzero(ha_data, sizeof(ha_data));
   mysys_var=0;
   binlog_evt_union.do_union= FALSE;
+  examined_row_count = 0;
+  busy_time = 0;
+  cpu_time = 0;
+  bytes_received = 0;
+  bytes_sent = 0;
+  binlog_bytes_written = 0;
+  updated_row_count = 0;
   enable_slow_log= 0;
 #ifndef DBUG_OFF
   dbug_sentry=THD_SENTRY_MAGIC;
@@ -878,13 +885,96 @@ void THD::init(void)
   reset_current_stmt_binlog_row_based();
   bzero((char *) &status_var, sizeof(status_var));
   sql_log_bin_toplevel= options & OPTION_BIN_LOG;
-
+  reset_stats();
 #if defined(ENABLED_DEBUG_SYNC)
   /* Initialize the Debug Sync Facility. See debug_sync.cc. */
   debug_sync_init_thread(this);
 #endif /* defined(ENABLED_DEBUG_SYNC) */
 }
 
+// Resets stats in a THD.
+void THD::reset_stats(void) {
+    current_connect_time = time(NULL);
+    last_global_update_time = current_connect_time;
+    reset_diff_stats();
+}
+
+// Resets the 'diff' stats, which are used to update global stats.
+void THD::reset_diff_stats(void) {
+  diff_total_busy_time= 0;
+  diff_total_cpu_time= 0;
+  diff_total_bytes_received= 0;
+  diff_total_bytes_sent= 0;
+  diff_total_binlog_bytes_written= 0;
+  diff_total_examined_rows= 0;
+  diff_total_sent_rows= 0;
+  diff_total_updated_rows= 0;
+  diff_total_read_rows= 0;
+  diff_select_commands= 0;
+  diff_update_commands= 0;
+  diff_other_commands= 0;
+  diff_commit_trans= 0;
+  diff_rollback_trans= 0;
+  diff_denied_connections= 0;
+  diff_lost_connections= 0;
+  diff_access_denied_errors= 0;
+  diff_empty_queries= 0;
+}
+
+// Updates 'diff' stats of a THD.
+void THD::update_stats(bool ran_command) {
+  diff_total_busy_time += busy_time;
+  diff_total_cpu_time += cpu_time;
+  diff_total_bytes_received += bytes_received;
+  diff_total_bytes_sent += bytes_sent;
+  diff_total_binlog_bytes_written += binlog_bytes_written;
+  diff_total_examined_rows += examined_row_count;
+  diff_total_sent_rows += sent_row_count;
+  diff_total_updated_rows += updated_row_count;
+  // The replication thread has the COM_CONNECT command.
+  if (ran_command) {
+    if ((old_command == COM_QUERY || command == COM_CONNECT) &&
+        (lex->sql_command >= 0 && lex->sql_command < SQLCOM_END)) {
+      // A SQL query.
+      if (lex->sql_command == SQLCOM_SELECT) {
+        if (!(sql_command_flags[lex->sql_command] & CF_STATUS_COMMAND)) {
+          diff_select_commands++;
+          if (!sent_row_count)
+            diff_empty_queries++;
+        } else {
+          // 'SHOW ' commands become SQLCOM_SELECT.
+          diff_other_commands++;
+          // 'SHOW ' commands shouldn't inflate total sent row count.
+          diff_total_sent_rows -= sent_row_count;
+        }
+      } else if (is_update_query(lex->sql_command)) {
+        diff_update_commands++;
+      } else {
+        diff_other_commands++;
+      }
+    }
+  }
+  // diff_commit_trans is updated in handler.cc.
+  // diff_rollback_trans is updated in handler.cc.
+  // diff_denied_connections is updated in sql_parse.cc.
+  // diff_lost_connections is updated in sql_parse.cc.
+  // diff_access_denied_errors is updated in sql_parse.cc.
+
+#if 0
+  /* reset counters to zero to avoid double-counting since values
+     are already store in diff_total_*. */
+  /* NOooo! (WWhipple 9/18/2009). If we reset these now, it
+     breaks the slow query log ... */
+  busy_time = 0;
+  cpu_time = 0;
+  bytes_received = 0;
+  bytes_sent = 0;
+  binlog_bytes_written = 0;
+  examined_row_count = 0;
+  sent_row_count = 0;
+  updated_row_count = 0;
+#endif
+}
 
 /*
   Init THD for query processing.
@@ -1548,6 +1638,32 @@ void THD::close_active_vio()
 }
 #endif
 
+char *THD::get_client_host_port(THD *client)
+{
+    Security_context *client_sctx= client->security_ctx;
+    char *client_host= NULL;
+
+    if (client->peer_port && (client_sctx->host || client_sctx->ip) &&
+        security_ctx->host_or_ip[0])
+      {
+          if ((client_host= (char*)this->alloc(LIST_PROCESS_HOST_LEN+1)))
+              my_snprintf((char *) client_host, LIST_PROCESS_HOST_LEN,
+                          "%s:%u", client_sctx->host_or_ip, client->peer_port);
+      }
+    else
+        client_host= this->strdup(client_sctx->host_or_ip[0] ?
+                                  client_sctx->host_or_ip :
+                                  client_sctx->host ? client_sctx->host : "");
+
+    return client_host;
+}
+
+const char *get_client_host(THD *client)
+{
+  return client->security_ctx->host_or_ip[0] ?
+    client->security_ctx->host_or_ip :
+    client->security_ctx->host ? client->security_ctx->host : "";
+}
 
 struct Item_change_record: public ilink
 {
@@ -2871,6 +2987,7 @@ void thd_increment_bytes_sent(ulong length)
   if (likely(thd != 0))
   { /* current_thd==0 when close_connection() calls net_send_error() */
     thd->status_var.bytes_sent+= length;
+    thd->bytes_sent+= length;
   }
 }
 
@@ -2878,6 +2995,7 @@ void thd_increment_bytes_sent(ulong length)
 void thd_increment_bytes_received(ulong length)
 {
   current_thd->status_var.bytes_received+= length;
+  current_thd->bytes_received+= length;
 }
 
 
diff --git a/sql/sql_class.h b/sql/sql_class.h
index 5cdb005..ea081c9 100644
--- a/sql/sql_class.h
+++ b/sql/sql_class.h
@@ -1429,6 +1429,9 @@ public:
     first byte of the packet in do_command()
   */
   enum enum_server_command command;
+  // Used to save the command, before it is set to COM_SLEEP.
+  enum enum_server_command old_command;
+
   uint32     server_id;
   uint32     file_id;			// for LOAD DATA INFILE
   /* remote (peer) port */
@@ -1795,6 +1798,7 @@ public:
   /* variables.transaction_isolation is reset to this after each commit */
   enum_tx_isolation session_tx_isolation;
   enum_check_fields count_cuted_fields;
+  ha_rows    updated_row_count;
 
   DYNAMIC_ARRAY user_var_events;        /* For user variables replication */
   MEM_ROOT      *user_var_events_alloc; /* Allocate above array elements here */
@@ -1883,6 +1887,52 @@ public:
   */
   LOG_INFO*  current_linfo;
   NET*       slave_net;			// network connection from slave -> m.
+
+  /*
+    Used to update global user stats.  The global user stats are updated
+    occasionally with the 'diff' variables.  After the update, the 'diff'
+    variables are reset to 0.
+  */
+  // Time when the current thread connected to MySQL.
+  time_t current_connect_time;
+  // Last time when THD stats were updated in global_user_stats.
+  time_t last_global_update_time;
+  // Busy (non-idle) time for just one command.
+  double busy_time;
+  // Busy time not updated in global_user_stats yet.
+  double diff_total_busy_time;
+  // Cpu (non-idle) time for just one thread.
+  double cpu_time;
+  // Cpu time not updated in global_user_stats yet.
+  double diff_total_cpu_time;
+
+  /* bytes counting */
+  ulonglong bytes_received;
+  ulonglong diff_total_bytes_received;
+  ulonglong bytes_sent;
+  ulonglong diff_total_bytes_sent;
+  ulonglong binlog_bytes_written;
+  ulonglong diff_total_binlog_bytes_written;
+
+  // Number of rows examined.
+  ha_rows diff_total_examined_rows;
+  // Number of rows not reflected in global_user_stats yet.
+  ha_rows diff_total_sent_rows, diff_total_updated_rows, diff_total_read_rows;
+  // Number of commands not reflected in global_user_stats yet.
+  ulonglong diff_select_commands, diff_update_commands, diff_other_commands;
+  // Number of transactions not reflected in global_user_stats yet.
+  ulonglong diff_commit_trans, diff_rollback_trans;
+  // Number of connection errors not reflected in global_user_stats yet.
+  ulonglong diff_denied_connections, diff_lost_connections;
+  // Number of db access denied, not reflected in global_user_stats yet.
+  ulonglong diff_access_denied_errors;
+  // Number of queries that return 0 rows
+  ulonglong diff_empty_queries;
+
+  // Per account query delay in miliseconds. When not 0, sleep this number of
+  // milliseconds before every SQL command.
+  ulonglong query_delay_millis;
+
   /* Used by the sys_var class to store temporary values */
   union
   {
@@ -1948,6 +1998,9 @@ public:
     alloc_root. 
   */
   void init_for_queries();
+  void reset_stats(void);
+  void reset_diff_stats(void);
+  void update_stats(bool ran_command);
   void change_user(void);
   void cleanup(void);
   void cleanup_after_query();
@@ -2317,6 +2370,15 @@ public:
     *p_db_length= db_length;
     return FALSE;
   }
+
+  /* 
+    Returns string as 'IP:port' for the client-side of the connnection
+    represented by 'client' as displayed by SHOW
+    PROCESSLIST. Allocates memory from the heap of this THD and that
+    is not reclaimed immediately, so use sparingly. May return NULL.
+  */
+  char *get_client_host_port(THD *client);
+
   thd_scheduler scheduler;
 
 public:
@@ -2402,6 +2464,11 @@ private:
   LEX_STRING invoker_host;
 };
 
+// Returns string as 'IP' for the client-side of the connection represented by
+// 'client'. Does not allocate memory. May return "".
+const char *get_client_host(THD *client);
+
+#define LIST_PROCESS_HOST_LEN 64
 
 /** A short cut for thd->main_da.set_ok_status(). */
 
diff --git a/sql/sql_connect.cc b/sql/sql_connect.cc
index 21e2701..fc64d21 100644
--- a/sql/sql_connect.cc
+++ b/sql/sql_connect.cc
@@ -142,7 +142,11 @@ int check_for_max_user_connections(THD *thd, USER_CONN *uc)
 
 end:
   if (error)
+  {
+    statistic_increment(denied_connections, &LOCK_status);
     uc->connections--; // no need for decrease_user_connections() here
+  }
+
   (void) pthread_mutex_unlock(&LOCK_user_conn);
   DBUG_RETURN(error);
 }
@@ -199,8 +203,6 @@ void time_out_user_resource_limits(THD *thd, USER_CONN *uc)
 {
   ulonglong check_time= thd->start_utime;
   DBUG_ENTER("time_out_user_resource_limits");
-
-  /* If more than a hour since last check, reset resource checking */
   if (check_time  - uc->reset_utime >= LL(3600000000))
   {
     uc->questions=1;
@@ -478,6 +480,7 @@ check_user(THD *thd, enum enum_server_command command,
     general_log_print(thd, COM_CONNECT, ER(ER_NOT_SUPPORTED_AUTH_MODE));
     DBUG_RETURN(1);
   }
+  thd->diff_access_denied_errors++;
   my_error(ER_ACCESS_DENIED_ERROR, MYF(0),
            thd->main_security_ctx.user,
            thd->main_security_ctx.host_or_ip,
@@ -1446,6 +1449,13 @@ pthread_handler_t handle_one_connection(void *arg)
     if (login_connection(thd))
       goto end_thread;
 
+    thd->reset_stats();
+    // Updates global user connection stats.
+    if (increment_connection_count(thd, true)) {
+      net_send_error(thd, ER_OUTOFMEMORY);  // Out of memory
+      goto end_thread;
+    }
+
     prepare_new_connection_state(thd);
 
     while (!net->error && net->vio != 0 &&
@@ -1458,6 +1468,8 @@ pthread_handler_t handle_one_connection(void *arg)
    
 end_thread:
     close_connection(thd, 0, 1);
+    thd->update_stats(false);
+    update_global_user_stats(thd, true, time(NULL));
     if (thread_scheduler.end_thread(thd,1))
       return 0;                                 // Probably no-threads
 
diff --git a/sql/sql_delete.cc b/sql/sql_delete.cc
index e2eccff..d5032bd 100644
--- a/sql/sql_delete.cc
+++ b/sql/sql_delete.cc
@@ -454,6 +454,7 @@ cleanup:
     my_ok(thd, (ha_rows) thd->row_count_func);
     DBUG_PRINT("info",("%ld records deleted",(long) deleted));
   }
+  thd->updated_row_count += deleted;
   DBUG_RETURN(error >= 0 || thd->is_error());
 }
 
@@ -1061,6 +1062,7 @@ bool multi_delete::send_eof()
     thd->row_count_func= deleted;
     ::my_ok(thd, (ha_rows) thd->row_count_func);
   }
+  thd->updated_row_count += deleted;
   return 0;
 }
 
diff --git a/sql/sql_insert.cc b/sql/sql_insert.cc
index 4cd4568..fa9bb84 100644
--- a/sql/sql_insert.cc
+++ b/sql/sql_insert.cc
@@ -984,6 +984,7 @@ bool mysql_insert(THD *thd,TABLE_LIST *table_list,
     thd->row_count_func= info.copied + info.deleted + updated;
     ::my_ok(thd, (ulong) thd->row_count_func, id, buff);
   }
+  thd->updated_row_count += thd->row_count_func;
   thd->abort_on_warning= 0;
   DBUG_RETURN(FALSE);
 
@@ -3315,6 +3316,7 @@ bool select_insert::send_eof()
      thd->first_successful_insert_id_in_prev_stmt :
      (info.copied ? autoinc_value_of_last_inserted_row : 0));
   ::my_ok(thd, (ulong) thd->row_count_func, id, buff);
+  thd->updated_row_count += thd->row_count_func;
   DBUG_RETURN(0);
 }
 
diff --git a/sql/sql_lex.h b/sql/sql_lex.h
index d512190..6cbc0e6 100644
--- a/sql/sql_lex.h
+++ b/sql/sql_lex.h
@@ -121,7 +121,8 @@ enum enum_sql_command {
   SQLCOM_SHOW_CREATE_TRIGGER,
   SQLCOM_ALTER_DB_UPGRADE,
   SQLCOM_SHOW_PROFILE, SQLCOM_SHOW_PROFILES,
-
+  SQLCOM_SHOW_USER_STATS, SQLCOM_SHOW_TABLE_STATS, SQLCOM_SHOW_INDEX_STATS, 
+  SQLCOM_SHOW_CLIENT_STATS,
   /*
     When a command is added here, be sure it's also added in mysqld.cc
     in "struct show_var_st status_vars[]= {" ...
diff --git a/sql/sql_parse.cc b/sql/sql_parse.cc
index 6c376d2..137e5b5 100644
--- a/sql/sql_parse.cc
+++ b/sql/sql_parse.cc
@@ -23,14 +23,18 @@
 #include <m_ctype.h>
 #include <myisam.h>
 #include <my_dir.h>
+#include <pwd.h>
 
 #include "sp_head.h"
 #include "sp.h"
 #include "sp_cache.h"
 #include "events.h"
 #include "sql_trigger.h"
+#include "log.h"
 #include "debug_sync.h"
 
+#include <linux/unistd.h>
+
 /**
   @defgroup Runtime_Environment Runtime Environment
   @{
@@ -48,6 +52,45 @@
 
 static bool execute_sqlcom_select(THD *thd, TABLE_LIST *all_tables);
 static bool check_show_create_table_access(THD *thd, TABLE_LIST *table);
+static int increment_count_by_name(const char *name, const char *role_name,
+                                   HASH *users_or_clients, THD *thd);
+
+
+void init_user_stats(USER_STATS *user_stats,
+                     const char *user,
+                     const char *priv_user,
+                     uint total_connections,
+                     uint concurrent_connections,
+                     time_t connected_time,
+                     double busy_time,
+                     double cpu_time,
+                     ulonglong bytes_received,
+                     ulonglong bytes_sent,
+                     ulonglong binlog_bytes_written,
+                     ha_rows rows_examined,
+                     ha_rows rows_fetched,
+                     ha_rows rows_updated,
+                     ha_rows rows_read,
+                     ulonglong select_commands,
+                     ulonglong update_commands,
+                     ulonglong other_commands,
+                     ulonglong commit_trans,
+                     ulonglong rollback_trans,
+                     ulonglong denied_connections,
+                     ulonglong lost_connections,
+                     ulonglong access_denied_errors,
+                     ulonglong empty_queries
+);
+
+HASH global_user_stats;
+HASH global_client_stats;
+extern pthread_mutex_t LOCK_global_user_client_stats;
+
+HASH global_table_stats;
+extern pthread_mutex_t LOCK_global_table_stats;
+
+HASH global_index_stats;
+extern pthread_mutex_t LOCK_global_index_stats;
 
 const char *any_db="*any*";	// Special symbol for check_access
 
@@ -89,6 +132,11 @@ const char *xa_state_names[]={
   "NON-EXISTING", "ACTIVE", "IDLE", "PREPARED", "ROLLBACK ONLY"
 };
 
+/************************************************************
+  BetterLinux
+  Custom declarations
+*/
+
 /**
   Mark a XA transaction as rollback-only if the RM unilaterally
   rolled back the transaction branch.
@@ -211,6 +259,188 @@ bool begin_trans(THD *thd)
   return error;
 }
 
+// Used to update the global user stats.
+static void update_global_user_stats_with_user(THD* thd,
+                                               USER_STATS* user_stats,
+                                               time_t now) 
+{
+  user_stats->connected_time += now - thd->last_global_update_time;
+  thd->last_global_update_time = now;
+  user_stats->busy_time += thd->diff_total_busy_time;
+  user_stats->cpu_time += thd->diff_total_cpu_time;
+  user_stats->bytes_received += thd->diff_total_bytes_received;
+  user_stats->bytes_sent += thd->diff_total_bytes_sent;
+  user_stats->binlog_bytes_written += thd->diff_total_binlog_bytes_written;
+  user_stats->rows_examined += thd->diff_total_examined_rows;
+  user_stats->rows_fetched += thd->diff_total_sent_rows;
+  user_stats->rows_updated += thd->diff_total_updated_rows;
+  user_stats->rows_read += thd->diff_total_read_rows;
+  user_stats->select_commands += thd->diff_select_commands;
+  user_stats->update_commands += thd->diff_update_commands;
+  user_stats->other_commands += thd->diff_other_commands;
+  user_stats->commit_trans += thd->diff_commit_trans;
+  user_stats->rollback_trans += thd->diff_rollback_trans;
+  user_stats->denied_connections += thd->diff_denied_connections;
+  user_stats->lost_connections += thd->diff_lost_connections;
+  user_stats->access_denied_errors += thd->diff_access_denied_errors;
+  user_stats->empty_queries += thd->diff_empty_queries;
+}
+
+// 'mysql_system_user' is used for when the user is not defined for a THD.
+static char mysql_system_user[] = "#mysql_system#";
+
+// Returns 'user' if it's not NULL.  Returns 'mysql_system_user' otherwise.
+static char* get_valid_user_string(char* user) {
+    return user ? user : mysql_system_user;
+}
+
+// Increments the global user and client stats connection count.  If 'use_lock'
+// is true, LOCK_global_user_client_stats will be locked/unlocked.  Returns
+// 0 on success, 1 on error.
+int increment_connection_count(THD* thd, bool use_lock)
+{
+    char* user_string = get_valid_user_string(thd->main_security_ctx.user);
+    const char* client_string = get_client_host(thd);
+    int return_value = 0;
+
+    if (use_lock) pthread_mutex_lock(&LOCK_global_user_client_stats);
+
+    if (increment_count_by_name(user_string, user_string,
+                                &global_user_stats, thd))
+      {
+          return_value = 1;
+          goto end;
+      }
+    if (increment_count_by_name(client_string,
+                                user_string,
+                                &global_client_stats, thd))
+      {
+          return_value = 1;
+          goto end;
+      }
+
+ end:
+    if (use_lock) pthread_mutex_unlock(&LOCK_global_user_client_stats);
+    return return_value;
+}
+
+// Increments the global stats connection count for an entry from
+// global_client_stats or global_user_stats. Returns 0 on success
+// and 1 on error.
+static int increment_count_by_name(const char *name, const char *role_name,
+                                   HASH *users_or_clients, THD *thd)
+{
+  USER_STATS* user_stats;
+
+  if (!(user_stats = (USER_STATS*)hash_search(users_or_clients, (const uchar*)name,
+                                              strlen(name))))
+  {
+    // First connection for this user or client
+    if (!(user_stats = ((USER_STATS*)
+                        my_malloc(sizeof(USER_STATS), MYF(MY_WME)))))
+    {
+      return 1; // Out of memory
+    }
+    
+    init_user_stats(user_stats, name, role_name,
+                    0, 0,      // connections
+                    0, 0, 0,   // time
+                    0, 0, 0,   // bytes sent, received and written
+                    0,         // rows examined
+                    0, 0, 0,   // rows fetched, updated and read
+                    0, 0, 0,   // select, update and other commands
+                    0, 0,      // commit and rollback trans
+                    thd->diff_denied_connections,
+                    0,         // lost connections
+                    0,         // access denied errors
+                    0);
+    
+    if (my_hash_insert(users_or_clients, (uchar*)user_stats))
+    {
+      my_free((char*)user_stats, 0);
+      return 1; // Out of memory
+    }
+  }
+  user_stats->total_connections++;
+  return 0;
+}
+
+// Determines the concurrent number of connections of current threads.
+void set_concurrent_connections_stats() {
+  USER_STATS* user_stats;
+  
+  pthread_mutex_lock(&LOCK_global_user_client_stats);
+  pthread_mutex_lock(&LOCK_thread_count);
+  
+  // Resets all concurrent connections to 0.
+  for (uint i = 0; i < global_user_stats.records; ++i) {
+    user_stats = (USER_STATS*)hash_element(&global_user_stats, i);
+    user_stats->concurrent_connections = 0;
+  }
+  
+  I_List_iterator<THD> it(threads);
+  THD* thd;
+  // Iterates through the current threads.
+  while ((thd = it++)) {
+    char* user_string = get_valid_user_string(thd->main_security_ctx.user);
+    if ((user_stats = (USER_STATS*)hash_search(&global_user_stats,
+                                               (uchar*)user_string,
+                                               strlen(user_string)))) {
+      // Found user.
+      user_stats->concurrent_connections++;
+      update_global_user_stats_with_user(thd, user_stats, time(NULL));
+      thd->reset_diff_stats();
+    } else {
+      // The user name should exist.
+      increment_connection_count(thd, false);
+    }
+  }
+  pthread_mutex_unlock(&LOCK_thread_count);
+  pthread_mutex_unlock(&LOCK_global_user_client_stats);
+}
+
+// Updates the global stats of a user or client
+void update_global_user_stats(THD* thd, bool create_user, time_t now)
+{
+  char* user_string = get_valid_user_string(thd->main_security_ctx.user);
+  const char* client_string = get_client_host(thd);
+
+  USER_STATS* user_stats;
+  pthread_mutex_lock(&LOCK_global_user_client_stats);
+
+  // Update by user name
+  if ((user_stats = (USER_STATS*)hash_search(&global_user_stats,
+                                             (uchar*)user_string,
+                                             strlen(user_string)))) {
+    // Found user.
+    update_global_user_stats_with_user(thd, user_stats, now);
+  } else {
+    // Create the entry
+    if (create_user) {
+      increment_count_by_name(user_string, user_string,
+                              &global_user_stats, thd);
+    }
+  }
+
+  // Update by client IP
+  if ((user_stats = (USER_STATS*)hash_search(&global_client_stats,
+                                             (uchar*)client_string,
+                                             strlen(client_string)))) {
+    // Found by client IP
+    update_global_user_stats_with_user(thd, user_stats, now);
+  } else {
+    // Create the entry
+    if (create_user) {
+      increment_count_by_name(client_string,
+                              user_string,
+                              &global_client_stats, thd);
+    }
+  }
+  thd->reset_diff_stats();
+  
+  pthread_mutex_unlock(&LOCK_global_user_client_stats);
+}
+
 #ifdef HAVE_REPLICATION
 /**
   Returns true if all tables should be ignored.
@@ -334,8 +564,11 @@ void init_update_queries(void)
   sql_command_flags[SQLCOM_SHOW_CREATE_EVENT]=  CF_STATUS_COMMAND;
   sql_command_flags[SQLCOM_SHOW_PROFILES]= CF_STATUS_COMMAND;
   sql_command_flags[SQLCOM_SHOW_PROFILE]= CF_STATUS_COMMAND;
-
-   sql_command_flags[SQLCOM_SHOW_TABLES]=       (CF_STATUS_COMMAND |
+  sql_command_flags[SQLCOM_SHOW_USER_STATS]= CF_STATUS_COMMAND;
+  sql_command_flags[SQLCOM_SHOW_CLIENT_STATS]= CF_STATUS_COMMAND;
+  sql_command_flags[SQLCOM_SHOW_TABLE_STATS]= CF_STATUS_COMMAND;
+  sql_command_flags[SQLCOM_SHOW_INDEX_STATS]= CF_STATUS_COMMAND;
+  sql_command_flags[SQLCOM_SHOW_TABLES]=       (CF_STATUS_COMMAND |
                                                  CF_SHOW_TABLE_COMMAND |
                                                  CF_REEXECUTION_FRAGILE);
   sql_command_flags[SQLCOM_SHOW_TABLE_STATUS]= (CF_STATUS_COMMAND |
@@ -571,6 +804,204 @@ end:
   return 0;
 }
 
+extern "C" uchar *get_key_user_stats(USER_STATS *user_stats, size_t *length,
+                                     my_bool not_used __attribute__((unused)))
+{
+  *length = strlen(user_stats->user);
+  return (uchar*)user_stats->user;
+}
+
+extern "C" void free_user_stats(USER_STATS* user_stats)
+{
+  my_free((char*)user_stats, MYF(0));
+}
+
+void init_user_stats(USER_STATS *user_stats,
+                     const char *user,
+                     const char *priv_user,
+                     uint total_connections,
+                     uint concurrent_connections,
+                     time_t connected_time,
+                     double busy_time,
+                     double cpu_time,
+                     ulonglong bytes_received,
+                     ulonglong bytes_sent,
+                     ulonglong binlog_bytes_written,
+                     ha_rows rows_examined,
+                     ha_rows rows_fetched,
+                     ha_rows rows_updated,
+                     ha_rows rows_read,
+                     ulonglong select_commands,
+                     ulonglong update_commands,
+                     ulonglong other_commands,
+                     ulonglong commit_trans,
+                     ulonglong rollback_trans,
+                     ulonglong denied_connections,
+                     ulonglong lost_connections,
+                     ulonglong access_denied_errors,
+                     ulonglong empty_queries
+)   /* Seconds */
+{
+  DBUG_ENTER("init_user_stats");
+  DBUG_PRINT("info",
+             ("Add user_stats entry for user %s - priv_user %s",
+              user, priv_user));
+  strncpy(user_stats->user, user, sizeof(user_stats->user));
+  strncpy(user_stats->priv_user, priv_user, sizeof(user_stats->priv_user));
+  
+  user_stats->total_connections = total_connections;
+  user_stats->concurrent_connections = concurrent_connections;
+  user_stats->connected_time = connected_time;
+  user_stats->busy_time = busy_time;
+  user_stats->cpu_time = cpu_time;
+  user_stats->bytes_received = bytes_received;
+  user_stats->bytes_sent = bytes_sent;
+  user_stats->binlog_bytes_written = binlog_bytes_written;
+  user_stats->rows_examined = rows_examined;
+  user_stats->rows_fetched = rows_fetched;
+  user_stats->rows_updated = rows_updated;
+  user_stats->rows_read = rows_read;
+  user_stats->select_commands = select_commands;
+  user_stats->update_commands = update_commands;
+  user_stats->other_commands = other_commands;
+  user_stats->commit_trans = commit_trans;
+  user_stats->rollback_trans = rollback_trans;
+  user_stats->denied_connections = denied_connections;
+  user_stats->lost_connections = lost_connections;
+  user_stats->access_denied_errors = access_denied_errors;
+  user_stats->empty_queries = empty_queries;
+  DBUG_VOID_RETURN;
+}
+
+void add_user_stats(USER_STATS *user_stats,
+                    uint total_connections,
+                    uint concurrent_connections,
+                    time_t connected_time,
+                    double busy_time,
+                    double cpu_time,
+                    ulonglong bytes_received,
+                    ulonglong bytes_sent,
+                    ulonglong binlog_bytes_written,
+                    ha_rows rows_examined,
+                    ha_rows rows_fetched,
+                    ha_rows rows_updated,
+                    ha_rows rows_read,
+                    ulonglong select_commands,
+                    ulonglong update_commands,
+                    ulonglong other_commands,
+                    ulonglong commit_trans,
+                    ulonglong rollback_trans,
+                    ulonglong denied_connections,
+                    ulonglong lost_connections,
+                    ulonglong access_denied_errors,
+                    ulonglong empty_queries) 
+{
+  user_stats->total_connections += total_connections;
+  user_stats->concurrent_connections += concurrent_connections;
+  user_stats->connected_time += connected_time;
+  user_stats->busy_time += busy_time;
+  user_stats->cpu_time += cpu_time;
+  user_stats->bytes_received += bytes_received;
+  user_stats->bytes_sent += bytes_sent;
+  user_stats->binlog_bytes_written += binlog_bytes_written;
+  user_stats->rows_examined += rows_examined;
+  user_stats->rows_fetched += rows_fetched;
+  user_stats->rows_updated += rows_updated;
+  user_stats->rows_read += rows_read;
+  user_stats->select_commands += select_commands;
+  user_stats->update_commands += update_commands;
+  user_stats->other_commands += other_commands;
+  user_stats->commit_trans += commit_trans;
+  user_stats->rollback_trans += rollback_trans;
+  user_stats->denied_connections += denied_connections;
+  user_stats->lost_connections += lost_connections;
+  user_stats->access_denied_errors += access_denied_errors;
+  user_stats->empty_queries += empty_queries;
+}
+
+void init_global_user_stats(void)
+{
+  if (hash_init(&global_user_stats, system_charset_info, max_connections,
+                0, 0, (hash_get_key)get_key_user_stats,
+                (hash_free_key)free_user_stats, 0)) {
+    sql_print_error("Initializing global_user_stats failed.");
+    exit(1);
+  }
+}
+
+void init_global_client_stats(void)
+{
+  if (hash_init(&global_client_stats, system_charset_info, max_connections,
+                0, 0, (hash_get_key)get_key_user_stats,
+                (hash_free_key)free_user_stats, 0)) {
+    sql_print_error("Initializing global_client_stats failed.");
+    exit(1);
+  }
+}
+
+extern "C" uchar *get_key_table_stats(TABLE_STATS *table_stats, size_t *length,
+                                      my_bool not_used __attribute__((unused)))
+{
+  *length = strlen(table_stats->table);
+  return (uchar*)table_stats->table;
+}
+
+extern "C" void free_table_stats(TABLE_STATS* table_stats)
+{
+  my_free((char*)table_stats, MYF(0));
+}
+
+void init_global_table_stats(void)
+{
+  if (hash_init(&global_table_stats, system_charset_info, max_connections,
+                0, 0, (hash_get_key)get_key_table_stats,
+                (hash_free_key)free_table_stats, 0)) {
+    sql_print_error("Initializing global_table_stats failed.");
+    exit(1);
+  }
+}
+
+extern "C" uchar *get_key_index_stats(INDEX_STATS *index_stats, size_t *length,
+                                      my_bool not_used __attribute__((unused)))
+{
+  *length = strlen(index_stats->index);
+  return (uchar*)index_stats->index;
+}
+
+extern "C" void free_index_stats(INDEX_STATS* index_stats)
+{
+  my_free((char*)index_stats, MYF(0));
+}
+
+void init_global_index_stats(void)
+{
+  if (hash_init(&global_index_stats, system_charset_info, max_connections,
+                0, 0, (hash_get_key)get_key_index_stats,
+                (hash_free_key)free_index_stats, 0)) {
+    sql_print_error("Initializing global_index_stats failed.");
+    exit(1);
+  }
+}
+
+void free_global_user_stats(void)
+{
+    hash_free(&global_user_stats);
+}
+
+void free_global_table_stats(void)
+{
+    hash_free(&global_table_stats);
+}
+
+void free_global_index_stats(void)
+{
+    hash_free(&global_index_stats);
+}
+
+void free_global_client_stats(void)
+{
+    hash_free(&global_client_stats);
+}
 
 /**
   @brief Check access privs for a MERGE table and fix children lock types.
@@ -828,6 +1259,15 @@ bool do_command(THD *thd)
     Consider moving to init_connect() instead.
   */
   thd->clear_error();				// Clear error message
+
+  thd->updated_row_count=0;
+  thd->busy_time=0;
+  thd->cpu_time=0;
+  thd->bytes_received=0;
+  thd->bytes_sent=0;
+  thd->binlog_bytes_written=0;
+  thd->sent_row_count=0;
+  thd->examined_row_count= 0;
   thd->main_da.reset_diagnostics_area();
 
   net_new_transaction(net);
@@ -998,6 +1438,9 @@ bool dispatch_command(enum enum_server_command command, THD *thd,
   DBUG_PRINT("info",("packet: '%*.s'; command: %d", packet_length, packet, command));
 
   thd->command=command;
+  // To increment the correct command counter for user stats, 'command' must
+  // be saved because it is set to COM_SLEEP at the end of this function.
+  thd->old_command = command;
   /*
     Commands which always take a long time are logged into
     the slow log only if opt_log_slow_admin_statements is set.
@@ -1211,7 +1654,7 @@ bool dispatch_command(enum enum_server_command command, THD *thd,
 #ifndef NO_EMBEDDED_ACCESS_CHECKS
       /* we've authenticated new user */
       if (save_user_connect)
-	decrease_user_connections(save_user_connect);
+        decrease_user_connections(save_user_connect);
 #endif /* NO_EMBEDDED_ACCESS_CHECKS */
       x_free(save_db);
       x_free(save_security_ctx.user);
@@ -1869,6 +2312,9 @@ int prepare_schema_table(THD *thd, LEX *lex, Table_ident *table_ident,
   case SCH_COLUMN_PRIVILEGES:
   case SCH_TABLE_CONSTRAINTS:
   case SCH_KEY_COLUMN_USAGE:
+  case SCH_USER_STATS:
+  case SCH_TABLE_STATS:
+  case SCH_INDEX_STATS:
   default:
     break;
   }
@@ -2028,6 +2474,7 @@ bool sp_process_definer(THD *thd)
                        thd->security_ctx->priv_host)) &&
         check_global_access(thd, SUPER_ACL))
     {
+      thd->diff_access_denied_errors++;
       my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0), "SUPER");
       DBUG_RETURN(TRUE);
     }
@@ -2280,6 +2727,10 @@ mysql_execute_command(THD *thd)
     my_error(ER_NOT_SUPPORTED_YET, MYF(0), "embedded server");
     break;
 #endif
+  case SQLCOM_SHOW_USER_STATS:
+  case SQLCOM_SHOW_CLIENT_STATS:
+  case SQLCOM_SHOW_TABLE_STATS:
+  case SQLCOM_SHOW_INDEX_STATS:
   case SQLCOM_SHOW_STATUS_PROC:
   case SQLCOM_SHOW_STATUS_FUNC:
     if (!(res= check_table_access(thd, SELECT_ACL, all_tables, UINT_MAX, FALSE)))
@@ -5374,6 +5825,7 @@ check_access(THD *thd, ulong want_access, const char *db, ulong *save_priv,
       if (!no_errors)
       {
         const char *db_name= db ? db : thd->db;
+        thd->diff_access_denied_errors++;
         my_error(ER_DBACCESS_DENIED_ERROR, MYF(0),
                  sctx->priv_user, sctx->priv_host, db_name);
       }
@@ -5406,12 +5858,15 @@ check_access(THD *thd, ulong want_access, const char *db, ulong *save_priv,
   {						// We can never grant this
     DBUG_PRINT("error",("No possible access"));
     if (!no_errors)
+    {
+      thd->diff_access_denied_errors++;
       my_error(ER_ACCESS_DENIED_ERROR, MYF(0),
                sctx->priv_user,
                sctx->priv_host,
                (thd->password ?
                 ER(ER_YES) :
                 ER(ER_NO)));                    /* purecov: tested */
+    }
     DBUG_RETURN(TRUE);				/* purecov: tested */
   }
 
@@ -5470,6 +5925,7 @@ static bool check_show_access(THD *thd, TABLE_LIST *table)
 
     if (!thd->col_access && check_grant_db(thd, dst_db_name))
     {
+      thd->diff_access_denied_errors++;
       my_error(ER_DBACCESS_DENIED_ERROR, MYF(0),
                thd->security_ctx->priv_user,
                thd->security_ctx->priv_host,
@@ -5497,6 +5953,9 @@ static bool check_show_access(THD *thd, TABLE_LIST *table)
 
     return (check_grant(thd, SELECT_ACL, dst_table, 2, UINT_MAX, FALSE));
   }
+  case SCH_USER_STATS:
+  case SCH_CLIENT_STATS:
+    return check_global_access(thd, SUPER_ACL | PROCESS_ACL);
   default:
     break;
   }
@@ -5551,9 +6010,12 @@ check_table_access(THD *thd, ulong want_access,TABLE_LIST *tables,
         (want_access & ~(SELECT_ACL | EXTRA_ACL | FILE_ACL)))
     {
       if (!no_errors)
+      {
+        thd->diff_access_denied_errors++;
         my_error(ER_DBACCESS_DENIED_ERROR, MYF(0),
                  sctx->priv_user, sctx->priv_host,
                  INFORMATION_SCHEMA_NAME.str);
+      }
       return TRUE;
     }
     /*
@@ -5716,6 +6178,7 @@ bool check_global_access(THD *thd, ulong want_access)
   if ((thd->security_ctx->master_access & want_access))
     return 0;
   get_privilege_desc(command, sizeof(command), want_access);
+  thd->diff_access_denied_errors++;
   my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0), command);
   return 1;
 #else
@@ -5859,6 +6322,10 @@ void mysql_reset_thd_for_next_command(THD *thd)
     reset_dynamic(&thd->user_var_events);
     thd->user_var_events_alloc= thd->mem_root;
   }
+  
+  thd->updated_row_count=0;
+  thd->busy_time=0;
+
   thd->clear_error();
   thd->main_da.reset_diagnostics_area();
   thd->total_warn_count=0;			// Warnings for this query
@@ -6074,6 +6541,39 @@ void mysql_parse(THD *thd, char *rawbuf, uint length,
   */
   lex_start(thd);
   mysql_reset_thd_for_next_command(thd);
+  /* Busy (clock) time */
+  int realtime_error = 0;
+  double start_nsecs = 0.0;
+  double end_nsecs = 0.0;
+
+  /* cpu time */
+  int cputime_error = 0;
+  double start_cpu_nsecs = 0.0;
+  double end_cpu_nsecs = 0.0;
+  double tot_cpu_nsecs = 0.0;
+
+  struct timespec tp = {0,0};     /* For CPU Time and Real Time */
+
+  /* Get CPU start time. (Note: since Linux threads are processes--and since the
+     thread-specific CPUTIME functions seem to be broken, call with the process-related
+     CPU Time constants.)
+  */
+#if 1
+  if (!(cputime_error = syscall(__NR_clock_gettime, CLOCK_THREAD_CPUTIME_ID, &tp))) {
+#else
+  if (!(cputime_error = sys_clock_gettime(CLOCK_THREAD_CPUTIME_ID, &tp))) {
+#endif
+    start_cpu_nsecs = tp.tv_sec*1000000000.0+tp.tv_nsec;
+  }
+
+  // Gets the start (wall-clock) time, in order to measure how long this command takes.
+#if 1
+  if (!(realtime_error = syscall(__NR_clock_gettime, CLOCK_REALTIME, &tp))) {
+#else
+  if (!(cputime_error = sys_clock_gettime(CLOCK_REALTIME, &tp))) {
+#endif
+    start_nsecs = tp.tv_sec * 1000000000.0 + tp.tv_nsec;
+  }
 
   if (query_cache_send_result_to_client(thd, rawbuf, length) <= 0)
   {
@@ -6155,6 +6655,48 @@ void mysql_parse(THD *thd, char *rawbuf, uint length,
     *found_semicolon= NULL;
   }
 
+  /* Get the end time. */
+  if (!realtime_error &&
+      !(realtime_error = syscall(__NR_clock_gettime, CLOCK_REALTIME, &tp))) {
+    end_nsecs = tp.tv_sec * 1000000000.0 + tp.tv_nsec;
+  }
+ 
+  /* Calculate the difference between the end and start times. */
+  if (!realtime_error && start_nsecs && (start_nsecs < end_nsecs)) {
+    thd->busy_time = (end_nsecs - start_nsecs) / 1000000000.0;
+    // In case there are bad values, 2629743 is the #seconds in a month.
+    if (thd->busy_time > 2629743) {
+      thd->busy_time = 0;
+    }
+  } else {
+    // end time went back in time, or clock_gettime failed.
+    thd->busy_time = 0;
+  }
+
+  /* Get end cputime */
+  if (!cputime_error &&
+      !(cputime_error = syscall(__NR_clock_gettime, CLOCK_THREAD_CPUTIME_ID, &tp))) {
+    end_cpu_nsecs = tp.tv_sec * 1000000000.0 + tp.tv_nsec;
+  }
+
+  /* Calculate difference between end and start CPU times */
+  if (!cputime_error && start_cpu_nsecs && (start_cpu_nsecs < end_cpu_nsecs)) 
+  {
+    tot_cpu_nsecs = end_cpu_nsecs - start_cpu_nsecs;
+    thd->cpu_time = tot_cpu_nsecs / 1000000000.0;
+  }
+  else 
+  {
+      thd->cpu_time = 0;
+  }
+
+
+  /******************************************************/
+
+  // Updates THD stats and the global user stats.
+  thd->update_stats(true);
+  update_global_user_stats(thd, true, time(NULL));
+
   DBUG_VOID_RETURN;
 }
 
@@ -7034,6 +7576,13 @@ bool reload_acl_and_cache(THD *thd, ulong options, TABLE_LIST *tables,
       result= 1;
     }
   }
+  if (options & REFRESH_SLOW_QUERY_LOG)
+  {
+     /*
+      We are only flushing slow query log
+     */
+     logger.flush_slow_log(thd);	
+  }
 #ifdef HAVE_QUERY_CACHE
   if (options & REFRESH_QUERY_CACHE_FREE)
   {
@@ -7155,6 +7704,39 @@ bool reload_acl_and_cache(THD *thd, ulong options, TABLE_LIST *tables,
    reset_mqh((LEX_USER *) NULL, 0);             /* purecov: inspected */
  if (*write_to_binlog != -1)
    *write_to_binlog= tmp_write_to_binlog;
+
+ if (options & REFRESH_TABLE_STATS)
+ {
+   pthread_mutex_lock(&LOCK_global_table_stats);
+   free_global_table_stats();
+   init_global_table_stats();
+   pthread_mutex_unlock(&LOCK_global_table_stats);
+ }
+ if (options & REFRESH_INDEX_STATS)
+ {
+   pthread_mutex_lock(&LOCK_global_index_stats);
+   free_global_index_stats();
+   init_global_index_stats();
+   pthread_mutex_unlock(&LOCK_global_index_stats);
+ }
+ if (options & (REFRESH_USER_STATS | REFRESH_CLIENT_STATS))
+ {
+   pthread_mutex_lock(&LOCK_global_user_client_stats);
+   if (options & REFRESH_USER_STATS)
+   {
+     free_global_user_stats();
+     init_global_user_stats();
+   }
+   if (options & REFRESH_CLIENT_STATS)
+   {
+     free_global_client_stats();
+     init_global_client_stats();
+   }
+   pthread_mutex_unlock(&LOCK_global_user_client_stats);
+ }
+
+ if (*write_to_binlog != -1)
+   *write_to_binlog= tmp_write_to_binlog;
  /*
    If the query was killed then this function must fail.
  */
diff --git a/sql/sql_show.cc b/sql/sql_show.cc
index 536822c..11c61c7 100644
--- a/sql/sql_show.cc
+++ b/sql/sql_show.cc
@@ -32,6 +32,7 @@
 #include <my_dir.h>
 #include "debug_sync.h"
 
+
 #define STR_OR_NIL(S) ((S) ? (S) : "<nil>")
 
 #ifdef WITH_PARTITION_STORAGE_ENGINE
@@ -81,6 +82,59 @@ static void store_key_options(THD *thd, String *packet, TABLE *table,
 static void
 append_algorithm(TABLE_LIST *table, String *buff);
 
+void init_user_stats(USER_STATS *user_stats,
+                     const char *user,
+                     const char *priv_user,
+                     uint total_connections,
+                     uint concurrent_connections,
+                     time_t connected_time,
+                     double busy_time,
+                     double cpu_time,
+                     ulonglong bytes_received,
+                     ulonglong bytes_sent,
+                     ulonglong binlog_bytes_written,
+                     ha_rows rows_examined,
+                     ha_rows rows_fetched,
+                     ha_rows rows_updated,
+                     ha_rows rows_read,
+                     ulonglong select_commands,
+                     ulonglong update_commands,
+                     ulonglong other_commands,
+                     ulonglong commit_trans,
+                     ulonglong rollback_trans,
+                     ulonglong denied_connections,
+                     ulonglong lost_connections,
+                     ulonglong access_denied_errors,
+                     ulonglong empty_queries);
+
+void add_user_stats(USER_STATS *user_stats,
+                    uint total_connections,
+                    uint concurrent_connections,
+                    time_t connected_time,
+                    double busy_time,
+                    double cpu_time,
+                    ulonglong bytes_received,
+                    ulonglong bytes_sent,
+                    ulonglong binlog_bytes_written,
+                    ha_rows rows_examined,
+                    ha_rows rows_fetched,
+                    ha_rows rows_updated,
+                    ha_rows rows_read,
+                    ulonglong select_commands,
+                    ulonglong update_commands,
+                    ulonglong other_commands,
+                    ulonglong commit_trans,
+                    ulonglong rollback_trans,
+                    ulonglong denied_connections,
+                    ulonglong lost_connections,
+                    ulonglong access_denied_errors,
+                    ulonglong empty_queries);
+
+extern "C" uchar *get_key_user_stats(USER_STATS *user_stats, size_t *length,
+                                     my_bool not_used __attribute__((unused)));
+
+extern "C" void free_user_stats(USER_STATS* user_stats);
+
 static COND * make_cond_for_info_schema(COND *cond, TABLE_LIST *table);
 
 /***************************************************************************
@@ -825,6 +879,7 @@ bool mysqld_show_create_db(THD *thd, char *dbname,
 		sctx->master_access);
   if (!(db_access & DB_ACLS) && check_grant_db(thd,dbname))
   {
+    thd->diff_access_denied_errors++;
     my_error(ER_DBACCESS_DENIED_ERROR, MYF(0),
              sctx->priv_user, sctx->host_or_ip, dbname);
     general_log_print(thd,COM_INIT_DB,ER(ER_DBACCESS_DENIED_ERROR),
@@ -2370,6 +2425,218 @@ end:
 }
 
 
+/*
+   Write result to network for SHOW USER_STATISTICS
+
+   SYNOPSIS
+     send_user_stats
+       all_user_stats - values to return
+       table - I_S table
+
+   RETURN
+     0 - OK
+     1 - error
+ */
+int send_user_stats(THD* thd, HASH *all_user_stats, TABLE *table)
+{
+  DBUG_ENTER("send_user_stats");
+  for (ulong i = 0; i < all_user_stats->records; ++i) {
+    restore_record(table, s->default_values);
+    USER_STATS *user_stats = (USER_STATS*)hash_element(all_user_stats, i);
+      table->field[0]->store(user_stats->user, strlen(user_stats->user), system_charset_info);
+      table->field[1]->store((longlong)user_stats->total_connections);
+      table->field[2]->store((longlong)user_stats->concurrent_connections);
+      table->field[3]->store((longlong)user_stats->connected_time);
+      table->field[4]->store((longlong)user_stats->busy_time);
+      table->field[5]->store((longlong)user_stats->cpu_time);
+      table->field[6]->store((longlong)user_stats->bytes_received);
+      table->field[7]->store((longlong)user_stats->bytes_sent);
+      table->field[8]->store((longlong)user_stats->binlog_bytes_written);
+      table->field[9]->store((longlong)user_stats->rows_examined);
+      table->field[10]->store((longlong)user_stats->rows_fetched);
+      table->field[11]->store((longlong)user_stats->rows_updated);
+      table->field[12]->store((longlong)user_stats->rows_read);
+      table->field[13]->store((longlong)user_stats->select_commands);
+      table->field[14]->store((longlong)user_stats->update_commands);
+      table->field[15]->store((longlong)user_stats->other_commands);
+      table->field[16]->store((longlong)user_stats->commit_trans);
+      table->field[17]->store((longlong)user_stats->rollback_trans);
+      table->field[18]->store((longlong)user_stats->denied_connections);
+      table->field[19]->store((longlong)user_stats->lost_connections);
+      table->field[20]->store((longlong)user_stats->access_denied_errors);
+      table->field[21]->store((longlong)user_stats->empty_queries);
+      if (schema_table_store_record(thd, table))
+      {
+              DBUG_PRINT("error", ("store record error"));
+              DBUG_RETURN(1);
+      }
+  }
+  DBUG_RETURN(0);
+}
+
+
+int fill_schema_user_stats(THD* thd, TABLE_LIST* tables, COND* cond)
+{
+  TABLE *table= tables->table;
+  DBUG_ENTER("fill_schema_user_stats");
+
+  set_concurrent_connections_stats();
+
+  pthread_mutex_lock(&LOCK_global_user_client_stats);
+  for (ulong i = 0; i < global_user_stats.records; ++i) {
+    restore_record(table, s->default_values);
+    USER_STATS *user_stats = (USER_STATS*)hash_element(&global_user_stats, i);
+    table->field[0]->store(user_stats->user, strlen(user_stats->user), system_charset_info);
+    table->field[1]->store((longlong)user_stats->total_connections, TRUE);
+    table->field[2]->store((longlong)user_stats->concurrent_connections, TRUE);
+    table->field[3]->store((longlong)user_stats->connected_time, TRUE);
+    table->field[4]->store((double)user_stats->busy_time); /* Omit boolean 2nd arg to match correct store method */
+    table->field[5]->store((double)user_stats->cpu_time);  /* Omit boolean 2nd arg to match correct store method */
+    table->field[6]->store((longlong)user_stats->bytes_received, TRUE);
+    table->field[7]->store((longlong)user_stats->bytes_sent, TRUE);
+    table->field[8]->store((longlong)user_stats->binlog_bytes_written, TRUE);
+    table->field[9]->store((longlong)user_stats->rows_examined, TRUE);
+    table->field[10]->store((longlong)user_stats->rows_fetched, TRUE);
+    table->field[11]->store((longlong)user_stats->rows_updated, TRUE);
+    table->field[12]->store((longlong)user_stats->rows_read, TRUE);
+    table->field[13]->store((longlong)user_stats->select_commands, TRUE);
+    table->field[14]->store((longlong)user_stats->update_commands, TRUE);
+    table->field[15]->store((longlong)user_stats->other_commands, TRUE);
+    table->field[16]->store((longlong)user_stats->commit_trans, TRUE);
+    table->field[17]->store((longlong)user_stats->rollback_trans, TRUE);
+    table->field[18]->store((longlong)user_stats->denied_connections, TRUE);
+    table->field[19]->store((longlong)user_stats->lost_connections, TRUE);
+    table->field[20]->store((longlong)user_stats->access_denied_errors, TRUE);
+    table->field[21]->store((longlong)user_stats->empty_queries, TRUE);
+    if (schema_table_store_record(thd, table))
+    {
+      VOID(pthread_mutex_unlock(&LOCK_global_user_client_stats));
+      DBUG_RETURN(1);
+    }
+  }
+  pthread_mutex_unlock(&LOCK_global_user_client_stats);
+  DBUG_RETURN(0);
+}
+
+int fill_schema_client_stats(THD* thd, TABLE_LIST* tables, COND* cond)
+{
+  TABLE *table= tables->table;
+  DBUG_ENTER("fill_schema_client_stats");
+
+  if (check_global_access(thd, SUPER_ACL | PROCESS_ACL))
+          DBUG_RETURN(1);
+
+  // Iterates through all the global stats and sends them to the client.
+  // Pattern matching on the client IP is supported.
+
+  pthread_mutex_lock(&LOCK_global_user_client_stats);
+  int result= send_user_stats(thd, &global_client_stats, table);
+  pthread_mutex_unlock(&LOCK_global_user_client_stats);
+  if (result)
+    goto err;
+
+  DBUG_PRINT("exit", ("mysqld_show_client_stats result is 0"));
+  DBUG_RETURN(0);
+
+ err:
+  DBUG_PRINT("exit", ("mysqld_show_client_stats result is 1"));
+  DBUG_RETURN(1);
+}
+
+// Sends the global table stats back to the client.
+int fill_schema_table_stats(THD* thd, TABLE_LIST* tables, COND* cond)
+{
+  TABLE *table= tables->table;
+  DBUG_ENTER("fill_schema_table_stats");
+
+  if (check_global_access(thd, SUPER_ACL | PROCESS_ACL))
+          DBUG_RETURN(1);
+
+  char *table_full_name, *table_schema;
+
+  pthread_mutex_lock(&LOCK_global_table_stats);
+  for (ulong i = 0; i < global_table_stats.records; ++i) {
+    restore_record(table, s->default_values);
+    TABLE_STATS *table_stats = 
+      (TABLE_STATS*)hash_element(&global_table_stats, i);
+
+    table_full_name= thd->strdup(table_stats->table);
+    table_schema= strsep(&table_full_name, ".");
+
+    TABLE_LIST tmp_table;
+    bzero((char*) &tmp_table,sizeof(tmp_table));
+    tmp_table.table_name= table_full_name;
+    tmp_table.db= table_schema;
+    tmp_table.grant.privilege= 0;
+    if (check_access(thd, SELECT_ACL | EXTRA_ACL, tmp_table.db,
+                      &tmp_table.grant.privilege, 0, 0,
+                      is_schema_db(table_schema)) ||
+        (grant_option && check_grant(thd, SELECT_ACL, &tmp_table, 1, UINT_MAX, 1)))
+        continue;
+
+    table->field[0]->store(table_schema, strlen(table_schema), system_charset_info);
+    table->field[1]->store(table_full_name, strlen(table_full_name), system_charset_info);
+    table->field[2]->store((longlong)table_stats->rows_read, TRUE);
+    table->field[3]->store((longlong)table_stats->rows_changed, TRUE);
+    table->field[4]->store((longlong)table_stats->rows_changed_x_indexes, TRUE);
+
+    if (schema_table_store_record(thd, table))
+    {
+      VOID(pthread_mutex_unlock(&LOCK_global_table_stats));
+      DBUG_RETURN(1);
+    }
+  }
+  pthread_mutex_unlock(&LOCK_global_table_stats);
+  DBUG_RETURN(0);
+}
+
+// Sends the global index stats back to the client.
+int fill_schema_index_stats(THD* thd, TABLE_LIST* tables, COND* cond)
+{
+  TABLE *table= tables->table;
+  DBUG_ENTER("fill_schema_index_stats");
+
+  if (check_global_access(thd, SUPER_ACL | PROCESS_ACL))
+          DBUG_RETURN(1);
+
+  char *index_full_name, *table_schema, *table_name;
+
+  pthread_mutex_lock(&LOCK_global_index_stats);
+  for (ulong i = 0; i < global_index_stats.records; ++i) {
+    restore_record(table, s->default_values);
+    INDEX_STATS *index_stats =
+      (INDEX_STATS*)hash_element(&global_index_stats, i);
+
+    index_full_name= thd->strdup(index_stats->index);
+    table_schema= strsep(&index_full_name, ".");
+    table_name= strsep(&index_full_name, ".");
+
+    TABLE_LIST tmp_table;
+    bzero((char*) &tmp_table,sizeof(tmp_table));
+    tmp_table.table_name= table_name;
+    tmp_table.db= table_schema;
+    tmp_table.grant.privilege= 0;
+    if (check_access(thd, SELECT_ACL | EXTRA_ACL, tmp_table.db,
+                      &tmp_table.grant.privilege, 0, 0,
+                      is_schema_db(table_schema)) ||
+        (grant_option && check_grant(thd, SELECT_ACL, &tmp_table, 1, UINT_MAX, 1)))
+        continue;
+
+    table->field[0]->store(table_schema, strlen(table_schema), system_charset_info);
+    table->field[1]->store(table_name, strlen(table_name), system_charset_info);
+    table->field[2]->store(index_full_name, strlen(index_full_name), system_charset_info);
+    table->field[3]->store((longlong)index_stats->rows_read, TRUE);
+
+    if (schema_table_store_record(thd, table))
+    { 
+      VOID(pthread_mutex_unlock(&LOCK_global_index_stats));
+      DBUG_RETURN(1);
+    }
+  }
+  pthread_mutex_unlock(&LOCK_global_index_stats);
+  DBUG_RETURN(0);
+}
+
 /* collect status for all running threads */
 
 void calc_sum_of_all_status(STATUS_VAR *to)
@@ -6869,6 +7136,79 @@ ST_FIELD_INFO referential_constraints_fields_info[]=
   {0, 0, MYSQL_TYPE_STRING, 0, 0, 0, SKIP_OPEN_TABLE}
 };
 
+ST_FIELD_INFO user_stats_fields_info[]=
+{
+  {"USER", HOSTNAME_LENGTH, MYSQL_TYPE_STRING, 0, 0, "User", SKIP_OPEN_TABLE},
+  {"TOTAL_CONNECTIONS", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Total_connections", SKIP_OPEN_TABLE},
+  {"CONCURRENT_CONNECTIONS", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Concurrent_connections", SKIP_OPEN_TABLE},
+  {"CONNECTED_TIME", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Connected_time", SKIP_OPEN_TABLE},
+  {"BUSY_TIME", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Busy_time", SKIP_OPEN_TABLE},
+  {"CPU_TIME", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Cpu_time", SKIP_OPEN_TABLE},
+  {"BYTES_RECEIVED", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Bytes_received", SKIP_OPEN_TABLE},
+  {"BYTES_SENT", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Bytes_sent", SKIP_OPEN_TABLE},
+  {"BINLOG_BYTES_WRITTEN", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Binlog_bytes_written", SKIP_OPEN_TABLE},
+  {"ROWS_EXAMINED", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Rows_examined", SKIP_OPEN_TABLE},
+  {"ROWS_FETCHED", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Rows_fetched", SKIP_OPEN_TABLE},
+  {"ROWS_UPDATED", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Rows_updated", SKIP_OPEN_TABLE},
+  {"TABLE_ROWS_READ", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Table_rows_read", SKIP_OPEN_TABLE},
+  {"SELECT_COMMANDS", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Select_commands", SKIP_OPEN_TABLE},
+  {"UPDATE_COMMANDS", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Update_commands", SKIP_OPEN_TABLE},
+  {"OTHER_COMMANDS", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Other_commands", SKIP_OPEN_TABLE},
+  {"COMMIT_TRANSACTIONS", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Commit_transactions", SKIP_OPEN_TABLE},
+  {"ROLLBACK_TRANSACTIONS", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Rollback_transactions", SKIP_OPEN_TABLE},
+  {"DENIED_CONNECTIONS", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Denied_connections", SKIP_OPEN_TABLE},
+  {"LOST_CONNECTIONS", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Lost_connections", SKIP_OPEN_TABLE},
+  {"ACCESS_DENIED", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Access_denied", SKIP_OPEN_TABLE},
+  {"EMPTY_QUERIES", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Empty_queries", SKIP_OPEN_TABLE},
+  {0, 0, MYSQL_TYPE_STRING, 0, 0, 0, SKIP_OPEN_TABLE}
+};
+
+ST_FIELD_INFO client_stats_fields_info[]=
+{
+  {"CLIENT", HOSTNAME_LENGTH, MYSQL_TYPE_STRING, 0, 0, "Client", SKIP_OPEN_TABLE},
+  {"TOTAL_CONNECTIONS", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Total_connections", SKIP_OPEN_TABLE},
+  {"CONCURRENT_CONNECTIONS", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Concurrent_connections", SKIP_OPEN_TABLE},
+  {"CONNECTED_TIME", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Connected_time", SKIP_OPEN_TABLE},
+  {"BUSY_TIME", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Busy_time", SKIP_OPEN_TABLE},
+  {"CPU_TIME", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Cpu_time", SKIP_OPEN_TABLE},
+  {"BYTES_RECEIVED", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Bytes_received", SKIP_OPEN_TABLE},
+  {"BYTES_SENT", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Bytes_sent", SKIP_OPEN_TABLE},
+  {"BINLOG_BYTES_WRITTEN", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Binlog_bytes_written", SKIP_OPEN_TABLE},
+  {"ROWS_EXAMINED", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Rows_examined", SKIP_OPEN_TABLE},
+  {"ROWS_FETCHED", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Rows_fetched", SKIP_OPEN_TABLE},
+  {"ROWS_UPDATED", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Rows_updated", SKIP_OPEN_TABLE},
+  {"TABLE_ROWS_READ", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Table_rows_read", SKIP_OPEN_TABLE},
+  {"SELECT_COMMANDS", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Select_commands", SKIP_OPEN_TABLE},
+  {"UPDATE_COMMANDS", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Update_commands", SKIP_OPEN_TABLE},
+  {"OTHER_COMMANDS", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Other_commands", SKIP_OPEN_TABLE},
+  {"COMMIT_TRANSACTIONS", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Commit_transactions", SKIP_OPEN_TABLE},
+  {"ROLLBACK_TRANSACTIONS", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Rollback_transactions", SKIP_OPEN_TABLE},
+  {"DENIED_CONNECTIONS", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Denied_connections", SKIP_OPEN_TABLE},
+  {"LOST_CONNECTIONS", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Lost_connections", SKIP_OPEN_TABLE},
+  {"ACCESS_DENIED", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Access_denied", SKIP_OPEN_TABLE},
+  {"EMPTY_QUERIES", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Empty_queries", SKIP_OPEN_TABLE},
+  {0, 0, MYSQL_TYPE_STRING, 0, 0, 0, SKIP_OPEN_TABLE}
+};
+
+ST_FIELD_INFO table_stats_fields_info[]=
+{
+  {"TABLE_SCHEMA", NAME_CHAR_LEN, MYSQL_TYPE_STRING, 0, 0, "Table_schema", SKIP_OPEN_TABLE},
+  {"TABLE_NAME", NAME_CHAR_LEN, MYSQL_TYPE_STRING, 0, 0, "Table_name", SKIP_OPEN_TABLE},
+  {"ROWS_READ", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Rows_read", SKIP_OPEN_TABLE},
+  {"ROWS_CHANGED", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Rows_changed", SKIP_OPEN_TABLE},
+  {"ROWS_CHANGED_X_INDEXES", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Rows_changed_x_#indexes", SKIP_OPEN_TABLE},
+  {0, 0, MYSQL_TYPE_STRING, 0, 0, 0, SKIP_OPEN_TABLE}
+};
+
+ST_FIELD_INFO index_stats_fields_info[]=
+{
+  {"TABLE_SCHEMA", NAME_CHAR_LEN, MYSQL_TYPE_STRING, 0, 0, "Table_schema", SKIP_OPEN_TABLE},
+  {"TABLE_NAME", NAME_CHAR_LEN, MYSQL_TYPE_STRING, 0, 0, "Table_name", SKIP_OPEN_TABLE},
+  {"INDEX_NAME", NAME_CHAR_LEN, MYSQL_TYPE_STRING, 0, 0, "Index_name", SKIP_OPEN_TABLE},
+  {"ROWS_READ", MY_INT64_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONGLONG, 0, 0, "Rows_read", SKIP_OPEN_TABLE},
+  {0, 0, MYSQL_TYPE_STRING, 0, 0, 0, SKIP_OPEN_TABLE}
+};
+
 
 /*
   Description of ST_FIELD_INFO in table.h
@@ -6881,6 +7221,8 @@ ST_SCHEMA_TABLE schema_tables[]=
 {
   {"CHARACTER_SETS", charsets_fields_info, create_schema_table, 
    fill_schema_charsets, make_character_sets_old_format, 0, -1, -1, 0, 0},
+  {"CLIENT_STATISTICS", client_stats_fields_info, create_schema_table, 
+    fill_schema_client_stats, make_old_format, 0, -1, -1, 0, 0},
   {"COLLATIONS", collation_fields_info, create_schema_table, 
    fill_schema_collation, make_old_format, 0, -1, -1, 0, 0},
   {"COLLATION_CHARACTER_SET_APPLICABILITY", coll_charset_app_fields_info,
@@ -6905,6 +7247,8 @@ ST_SCHEMA_TABLE schema_tables[]=
    fill_status, make_old_format, 0, 0, -1, 0, 0},
   {"GLOBAL_VARIABLES", variables_fields_info, create_schema_table,
    fill_variables, make_old_format, 0, 0, -1, 0, 0},
+  {"INDEX_STATISTICS", index_stats_fields_info, create_schema_table,
+   fill_schema_index_stats, make_old_format, 0, -1, -1, 0, 0},
   {"KEY_COLUMN_USAGE", key_column_usage_fields_info, create_schema_table,
    get_all_tables, 0, get_schema_key_column_usage_record, 4, 5, 0,
    OPEN_TABLE_ONLY},
@@ -6946,11 +7290,15 @@ ST_SCHEMA_TABLE schema_tables[]=
    get_all_tables, make_table_names_old_format, 0, 1, 2, 1, 0},
   {"TABLE_PRIVILEGES", table_privileges_fields_info, create_schema_table,
    fill_schema_table_privileges, 0, 0, -1, -1, 0, 0},
+  {"TABLE_STATISTICS", table_stats_fields_info, create_schema_table,
+   fill_schema_table_stats, make_old_format, 0, -1, -1, 0, 0},
   {"TRIGGERS", triggers_fields_info, create_schema_table,
    get_all_tables, make_old_format, get_schema_triggers_record, 5, 6, 0,
    OPEN_TABLE_ONLY},
   {"USER_PRIVILEGES", user_privileges_fields_info, create_schema_table, 
    fill_schema_user_privileges, 0, 0, -1, -1, 0, 0},
+  {"USER_STATISTICS", user_stats_fields_info, create_schema_table, 
+   fill_schema_user_stats, make_old_format, 0, -1, -1, 0, 0},
   {"VARIABLES", variables_fields_info, create_schema_table, fill_variables,
    make_old_format, 0, 0, -1, 1, 0},
   {"VIEWS", view_fields_info, create_schema_table, 
diff --git a/sql/sql_update.cc b/sql/sql_update.cc
index d943575..f46018a 100644
--- a/sql/sql_update.cc
+++ b/sql/sql_update.cc
@@ -890,6 +890,7 @@ int mysql_update(THD *thd,
     thd->row_count_func=
       (thd->client_capabilities & CLIENT_FOUND_ROWS) ? found : updated;
     my_ok(thd, (ulong) thd->row_count_func, id, buff);
+    thd->updated_row_count += thd->row_count_func;
     DBUG_PRINT("info",("%ld records updated", (long) updated));
   }
   thd->count_cuted_fields= CHECK_FIELD_IGNORE;		/* calc cuted fields */
@@ -2176,5 +2177,6 @@ bool multi_update::send_eof()
   thd->row_count_func=
     (thd->client_capabilities & CLIENT_FOUND_ROWS) ? found : updated;
   ::my_ok(thd, (ulong) thd->row_count_func, id, buff);
+  thd->updated_row_count += thd->row_count_func;
   DBUG_RETURN(FALSE);
 }
diff --git a/sql/sql_yacc.yy b/sql/sql_yacc.yy
index 7a6981f..e9ddc6d 100644
--- a/sql/sql_yacc.yy
+++ b/sql/sql_yacc.yy
@@ -759,6 +759,7 @@ bool my_yyoverflow(short **a, YYSTYPE **b, ulong *yystacksize);
 %token  CHECK_SYM                     /* SQL-2003-R */
 %token  CIPHER_SYM
 %token  CLIENT_SYM
+%token  CLIENT_STATS_SYM
 %token  CLOSE_SYM                     /* SQL-2003-R */
 %token  COALESCE                      /* SQL-2003-N */
 %token  CODE_SYM
@@ -905,6 +906,7 @@ bool my_yyoverflow(short **a, YYSTYPE **b, ulong *yystacksize);
 %token  IMPORT
 %token  INDEXES
 %token  INDEX_SYM
+%token  INDEX_STATS_SYM
 %token  INFILE
 %token  INITIAL_SIZE_SYM
 %token  INNER_SYM                     /* SQL-2003-R */
@@ -1145,6 +1147,7 @@ bool my_yyoverflow(short **a, YYSTYPE **b, ulong *yystacksize);
 %token  SIGNED_SYM
 %token  SIMPLE_SYM                    /* SQL-2003-N */
 %token  SLAVE
+%token  SLOW_SYM
 %token  SMALLINT                      /* SQL-2003-R */
 %token  SNAPSHOT_SYM
 %token  SOCKET_SYM
@@ -1191,6 +1194,7 @@ bool my_yyoverflow(short **a, YYSTYPE **b, ulong *yystacksize);
 %token  TABLE_REF_PRIORITY
 %token  TABLE_SYM                     /* SQL-2003-R */
 %token  TABLE_CHECKSUM_SYM
+%token  TABLE_STATS_SYM
 %token  TEMPORARY                     /* SQL-2003-N */
 %token  TEMPTABLE_SYM
 %token  TERMINATED
@@ -1235,6 +1239,7 @@ bool my_yyoverflow(short **a, YYSTYPE **b, ulong *yystacksize);
 %token  UPGRADE_SYM
 %token  USAGE                         /* SQL-2003-N */
 %token  USER                          /* SQL-2003-R */
+%token  USER_STATS_SYM
 %token  USE_FRM
 %token  USE_SYM
 %token  USING                         /* SQL-2003-R */
@@ -10382,6 +10387,34 @@ show_param:
           {
             Lex->sql_command = SQLCOM_SHOW_SLAVE_STAT;
           }
+        | CLIENT_STATS_SYM wild_and_where 
+          {
+           LEX *lex= Lex;
+           lex->sql_command= SQLCOM_SHOW_CLIENT_STATS;
+           if (prepare_schema_table(YYTHD, lex, 0, SCH_CLIENT_STATS))
+             MYSQL_YYABORT;
+          }
+        | USER_STATS_SYM wild_and_where
+          {
+             LEX *lex= Lex;
+             lex->sql_command= SQLCOM_SHOW_USER_STATS;
+             if (prepare_schema_table(YYTHD, lex, 0, SCH_USER_STATS))
+               MYSQL_YYABORT;
+          }
+        | TABLE_STATS_SYM wild_and_where
+          {
+             LEX *lex= Lex;
+             lex->sql_command= SQLCOM_SHOW_TABLE_STATS;
+             if (prepare_schema_table(YYTHD, lex, 0, SCH_TABLE_STATS))
+               MYSQL_YYABORT;
+          }
+        | INDEX_STATS_SYM wild_and_where
+          {
+             LEX *lex= Lex;
+             lex->sql_command= SQLCOM_SHOW_INDEX_STATS;
+             if (prepare_schema_table(YYTHD, lex, 0, SCH_INDEX_STATS))
+               MYSQL_YYABORT;
+          }
         | CREATE PROCEDURE sp_name
           {
             LEX *lex= Lex;
@@ -10590,12 +10623,22 @@ flush_option:
           { Lex->type|= REFRESH_STATUS; }
         | SLAVE
           { Lex->type|= REFRESH_SLAVE; }
+        | SLOW_SYM QUERY_SYM LOGS_SYM
+          { Lex->type |= REFRESH_SLOW_QUERY_LOG; }
         | MASTER_SYM
           { Lex->type|= REFRESH_MASTER; }
         | DES_KEY_FILE
           { Lex->type|= REFRESH_DES_KEY_FILE; }
         | RESOURCES
           { Lex->type|= REFRESH_USER_RESOURCES; }
+        | CLIENT_STATS_SYM
+          { Lex->type|= REFRESH_CLIENT_STATS; }
+        | USER_STATS_SYM
+          { Lex->type|= REFRESH_USER_STATS; }
+        | TABLE_STATS_SYM
+          { Lex->type|= REFRESH_TABLE_STATS; }
+        | INDEX_STATS_SYM
+          { Lex->type|= REFRESH_INDEX_STATS; }
         ;
 
 opt_table_list:
@@ -11713,6 +11756,7 @@ keyword_sp:
         | CHAIN_SYM                {}
         | CHANGED                  {}
         | CIPHER_SYM               {}
+        | CLIENT_STATS_SYM         {}
         | CLIENT_SYM               {}
         | COALESCE                 {}
         | CODE_SYM                 {}
@@ -11776,6 +11820,7 @@ keyword_sp:
         | IDENTIFIED_SYM           {}
         | INVOKER_SYM              {}
         | IMPORT                   {}
+        | INDEX_STATS_SYM          {}
         | INDEXES                  {}
         | INITIAL_SIZE_SYM         {}
         | IO_SYM                   {}
@@ -11897,6 +11942,7 @@ keyword_sp:
         | SIMPLE_SYM               {}
         | SHARE_SYM                {}
         | SHUTDOWN                 {}
+        | SLOW_SYM                 {}
         | SNAPSHOT_SYM             {}
         | SOUNDS_SYM               {}
         | SOURCE_SYM               {}
@@ -11916,6 +11962,7 @@ keyword_sp:
         | SUSPEND_SYM              {}
         | SWAPS_SYM                {}
         | SWITCHES_SYM             {}
+        | TABLE_STATS_SYM          {}
         | TABLES                   {}
         | TABLE_CHECKSUM_SYM       {}
         | TABLESPACE               {}
@@ -11940,6 +11987,7 @@ keyword_sp:
         | UNKNOWN_SYM              {}
         | UNTIL_SYM                {}
         | USER                     {}
+        | USER_STATS_SYM           {}
         | USE_FRM                  {}
         | VARIABLES                {}
         | VIEW_SYM                 {}
diff --git a/sql/structs.h b/sql/structs.h
index f364285..09216b5 100644
--- a/sql/structs.h
+++ b/sql/structs.h
@@ -240,6 +240,43 @@ typedef struct  user_conn {
   USER_RESOURCES user_resources;
 } USER_CONN;
 
+typedef struct st_user_stats {
+  char user[HOSTNAME_LENGTH + 1];
+  // Account name the user is mapped to when this is a user from mapped_user.
+  // Otherwise, the same value as user.
+  char priv_user[HOSTNAME_LENGTH + 1];
+  uint total_connections;
+  uint concurrent_connections;
+  time_t connected_time;  // in seconds
+  double busy_time;       // in seconds
+  double cpu_time;        // in seconds
+  ulonglong bytes_received;
+  ulonglong bytes_sent;
+  ulonglong binlog_bytes_written;
+  ha_rows rows_examined;
+  ha_rows rows_fetched, rows_updated, rows_read;
+  ulonglong select_commands, update_commands, other_commands;
+  ulonglong commit_trans, rollback_trans;
+  ulonglong denied_connections, lost_connections;
+  ulonglong access_denied_errors;
+  ulonglong empty_queries;
+} USER_STATS;
+
+
+typedef struct st_table_stats {
+  char table[NAME_LEN * 2 + 2];  // [db] + '.' + [table] + '\0'
+  ulonglong rows_read, rows_changed;
+  ulonglong rows_changed_x_indexes;
+  /* Stores enum db_type, but forward declarations cannot be done */
+  int engine_type;
+} TABLE_STATS;
+
+typedef struct st_index_stats {
+  char index[NAME_LEN * 3 + 3];  // [db] + '.' + [table] + '.' + [index] + '\0'
+  ulonglong rows_read;
+} INDEX_STATS;
+
+
 	/* Bits in form->update */
 #define REG_MAKE_DUPP		1	/* Make a copy of record when read */
 #define REG_NEW_RECORD		2	/* Write a new record if not found */
diff --git a/sql/table.h b/sql/table.h
index 690abdf..8396677 100644
--- a/sql/table.h
+++ b/sql/table.h
@@ -945,6 +945,7 @@ typedef struct st_foreign_key_info
 enum enum_schema_tables
 {
   SCH_CHARSETS= 0,
+  SCH_CLIENT_STATS,
   SCH_COLLATIONS,
   SCH_COLLATION_CHARACTER_SET_APPLICABILITY,
   SCH_COLUMNS,
@@ -954,6 +955,7 @@ enum enum_schema_tables
   SCH_FILES,
   SCH_GLOBAL_STATUS,
   SCH_GLOBAL_VARIABLES,
+  SCH_INDEX_STATS,
   SCH_KEY_COLUMN_USAGE,
   SCH_OPEN_TABLES,
   SCH_PARTITIONS,
@@ -972,8 +974,10 @@ enum enum_schema_tables
   SCH_TABLE_CONSTRAINTS,
   SCH_TABLE_NAMES,
   SCH_TABLE_PRIVILEGES,
+  SCH_TABLE_STATS,
   SCH_TRIGGERS,
   SCH_USER_PRIVILEGES,
+  SCH_USER_STATS,
   SCH_VARIABLES,
   SCH_VIEWS
 };
diff --git a/storage/innobase/handler/ha_innodb.cc b/storage/innobase/handler/ha_innodb.cc
index df465d0..818595c 100644
--- a/storage/innobase/handler/ha_innodb.cc
+++ b/storage/innobase/handler/ha_innodb.cc
@@ -4258,6 +4258,8 @@ no_commit:
 
 	error = row_insert_for_mysql((byte*) record, prebuilt);
 
+	if (error == DB_SUCCESS) rows_changed++;
+
 	/* Handle duplicate key errors */
 	if (auto_inc_used) {
 		ulint		err;
@@ -4558,6 +4560,8 @@ ha_innobase::update_row(
 
 	error = row_update_for_mysql((byte*) old_row, prebuilt);
 
+	if (error == DB_SUCCESS) rows_changed++;
+
 	/* We need to do some special AUTOINC handling for the following case:
 
 	INSERT INTO t (c1,c2) VALUES(x,y) ON DUPLICATE KEY UPDATE ...
@@ -4649,6 +4653,8 @@ ha_innobase::delete_row(
 
 	error = row_update_for_mysql((byte*) record, prebuilt);
 
+	if (error == DB_SUCCESS) rows_changed++;
+
 	innodb_srv_conc_exit_innodb(trx);
 
 	error = convert_error_code_to_mysql(error, user_thd);
@@ -4958,6 +4964,7 @@ ha_innobase::index_read(
 	if (ret == DB_SUCCESS) {
 		error = 0;
 		table->status = 0;
+		rows_read++;
 
 	} else if (ret == DB_RECORD_NOT_FOUND) {
 		error = HA_ERR_KEY_NOT_FOUND;
@@ -5130,6 +5137,7 @@ ha_innobase::general_fetch(
 	if (ret == DB_SUCCESS) {
 		error = 0;
 		table->status = 0;
+		rows_read++;
 
 	} else if (ret == DB_RECORD_NOT_FOUND) {
 		error = HA_ERR_END_OF_FILE;
diff --git a/storage/myisam/ha_myisam.cc b/storage/myisam/ha_myisam.cc
index 173dc35..64a0760 100644
--- a/storage/myisam/ha_myisam.cc
+++ b/storage/myisam/ha_myisam.cc
@@ -788,7 +788,9 @@ int ha_myisam::write_row(uchar *buf)
     if ((error= update_auto_increment()))
       return error;
   }
-  return mi_write(file,buf);
+  int error=mi_write(file,buf);
+  if (!error) rows_changed++;
+  return error;
 }
 
 int ha_myisam::check(THD* thd, HA_CHECK_OPT* check_opt)
@@ -1668,13 +1670,17 @@ int ha_myisam::update_row(const uchar *old_data, uchar *new_data)
   ha_statistic_increment(&SSV::ha_update_count);
   if (table->timestamp_field_type & TIMESTAMP_AUTO_SET_ON_UPDATE)
     table->timestamp_field->set_time();
-  return mi_update(file,old_data,new_data);
+  int error=mi_update(file,old_data,new_data);
+  if (!error) rows_changed++;
+  return error;
 }
 
 int ha_myisam::delete_row(const uchar *buf)
 {
   ha_statistic_increment(&SSV::ha_delete_count);
-  return mi_delete(file,buf);
+  int error=mi_delete(file,buf);
+  if (!error) rows_changed++;
+  return error;
 }
 
 int ha_myisam::index_read_map(uchar *buf, const uchar *key,
@@ -1685,6 +1691,13 @@ int ha_myisam::index_read_map(uchar *buf, const uchar *key,
   ha_statistic_increment(&SSV::ha_read_key_count);
   int error=mi_rkey(file, buf, active_index, key, keypart_map, find_flag);
   table->status=error ? STATUS_NOT_FOUND: 0;
+  if (!error) {
+    rows_read++;
+
+    uint inx = (active_index == (uint)-1) ? file->lastinx : active_index;
+    if (inx < MAX_KEY)
+      index_rows_read[inx]++;
+  }
   return error;
 }
 
@@ -1695,6 +1708,14 @@ int ha_myisam::index_read_idx_map(uchar *buf, uint index, const uchar *key,
   ha_statistic_increment(&SSV::ha_read_key_count);
   int error=mi_rkey(file, buf, index, key, keypart_map, find_flag);
   table->status=error ? STATUS_NOT_FOUND: 0;
+  if (!error) {
+    rows_read++;
+
+//    int inx = (active_index == -1) ? file->lastinx : active_index;
+    int inx = index;
+    if (inx >= 0 && inx < MAX_KEY)
+      index_rows_read[inx]++;
+  }
   return error;
 }
 
@@ -1716,6 +1737,13 @@ int ha_myisam::index_next(uchar *buf)
   ha_statistic_increment(&SSV::ha_read_next_count);
   int error=mi_rnext(file,buf,active_index);
   table->status=error ? STATUS_NOT_FOUND: 0;
+  if (!error) {
+    rows_read++;
+
+    uint inx = (active_index == (uint)-1) ? file->lastinx : active_index;
+    if (inx < MAX_KEY)
+      index_rows_read[inx]++;
+  }
   return error;
 }
 
@@ -1725,6 +1753,13 @@ int ha_myisam::index_prev(uchar *buf)
   ha_statistic_increment(&SSV::ha_read_prev_count);
   int error=mi_rprev(file,buf, active_index);
   table->status=error ? STATUS_NOT_FOUND: 0;
+  if (!error) {
+    rows_read++;
+
+    uint inx = (active_index == (uint)-1) ? file->lastinx : active_index;
+    if (inx < MAX_KEY)
+      index_rows_read[inx]++;
+  }
   return error;
 }
 
@@ -1734,6 +1769,13 @@ int ha_myisam::index_first(uchar *buf)
   ha_statistic_increment(&SSV::ha_read_first_count);
   int error=mi_rfirst(file, buf, active_index);
   table->status=error ? STATUS_NOT_FOUND: 0;
+  if (!error) {
+    rows_read++;
+
+    uint inx = (active_index == (uint)-1) ? file->lastinx : active_index;
+    if (inx < MAX_KEY)
+      index_rows_read[inx]++;
+  }
   return error;
 }
 
@@ -1743,6 +1785,13 @@ int ha_myisam::index_last(uchar *buf)
   ha_statistic_increment(&SSV::ha_read_last_count);
   int error=mi_rlast(file, buf, active_index);
   table->status=error ? STATUS_NOT_FOUND: 0;
+  if (!error) {
+    rows_read++;
+
+    uint inx = (active_index == (uint)-1) ? file->lastinx : active_index;
+    if (inx < MAX_KEY)
+      index_rows_read[inx]++;
+  }
   return error;
 }
 
@@ -1758,6 +1807,13 @@ int ha_myisam::index_next_same(uchar *buf,
     error= mi_rnext_same(file,buf);
   } while (error == HA_ERR_RECORD_DELETED);
   table->status=error ? STATUS_NOT_FOUND: 0;
+  if (!error) {
+    rows_read++;
+
+    uint inx = (active_index == (uint)-1) ? file->lastinx : active_index;
+    if (inx < MAX_KEY)
+      index_rows_read[inx]++;
+  }
   return error;
 }
 
@@ -1774,6 +1830,7 @@ int ha_myisam::rnd_next(uchar *buf)
   ha_statistic_increment(&SSV::ha_read_rnd_next_count);
   int error=mi_scan(file, buf);
   table->status=error ? STATUS_NOT_FOUND: 0;
+  if (!error) rows_read++;
   return error;
 }
 
@@ -1787,6 +1844,7 @@ int ha_myisam::rnd_pos(uchar *buf, uchar *pos)
   ha_statistic_increment(&SSV::ha_read_rnd_count);
   int error=mi_rrnd(file, buf, my_get_ptr(pos,ref_length));
   table->status=error ? STATUS_NOT_FOUND: 0;
+  if (!error) rows_read++;
   return error;
 }
 
