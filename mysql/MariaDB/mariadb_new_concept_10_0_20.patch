diff -rupN mariadb-10.0.20.old/.cproject mariadb-10.0.20.new/.cproject
diff -rupN mariadb-10.0.20.old/include/CMakeLists.txt mariadb-10.0.20.new/include/CMakeLists.txt
--- mariadb-10.0.20.old/include/CMakeLists.txt	2015-06-17 17:54:11.000000000 +0300
+++ mariadb-10.0.20.new/include/CMakeLists.txt	2015-09-27 22:49:38.000000000 +0300
@@ -60,6 +60,7 @@ SET(HEADERS 
   my_compiler.h
   handler_state.h
   handler_ername.h
+  governor.h
 )
 
 INSTALL(FILES ${HEADERS} DESTINATION ${INSTALL_INCLUDEDIR} COMPONENT Development)
diff -rupN mariadb-10.0.20.old/include/governor.h mariadb-10.0.20.new/include/governor.h
--- mariadb-10.0.20.old/include/governor.h	1970-01-01 03:00:00.000000000 +0300
+++ mariadb-10.0.20.new/include/governor.h	2015-09-27 22:49:38.000000000 +0300
@@ -0,0 +1,14 @@
+/*
+ * governor_pthread_wrapper.h
+ *
+ *  Created on: Sep 26, 2012
+ *      Author: alexey
+*/
+
+#ifndef GOVERNOR_PTHREAD_WRAPPER_H_
+#define GOVERNOR_PTHREAD_WRAPPER_H_
+
+#include <stdint.h>
+
+
+#endif /* GOVERNOR_PTHREAD_WRAPPER_H_ */
diff -rupN mariadb-10.0.20.old/include/m_ctype.h mariadb-10.0.20.new/include/m_ctype.h
--- mariadb-10.0.20.old/include/m_ctype.h	2015-06-17 17:54:11.000000000 +0300
+++ mariadb-10.0.20.new/include/m_ctype.h	2015-09-27 22:49:38.000000000 +0300
@@ -60,12 +60,12 @@ extern "C" {
 #define MY_PUT_MB2(s, code)   { (s)[0]= code >> 8; (s)[1]= code & 0xFF; }
 #endif
 
-typedef const struct my_charset_handler_st MY_CHARSET_HANDLER;
-typedef const struct my_collation_handler_st MY_COLLATION_HANDLER;
+typedef struct my_charset_handler_st MY_CHARSET_HANDLER;
+typedef struct my_collation_handler_st MY_COLLATION_HANDLER;
 
-typedef const struct unicase_info_st MY_UNICASE_INFO;
-typedef const struct uni_ctype_st MY_UNI_CTYPE;
-typedef const struct my_uni_idx_st MY_UNI_IDX;
+typedef struct unicase_info_st MY_UNICASE_INFO;
+typedef struct uni_ctype_st MY_UNI_CTYPE;
+typedef struct my_uni_idx_st MY_UNI_IDX;
 
 typedef struct unicase_info_char_st
 {
diff -rupN mariadb-10.0.20.old/include/my_pthread.h mariadb-10.0.20.new/include/my_pthread.h
--- mariadb-10.0.20.old/include/my_pthread.h	2015-06-17 17:54:11.000000000 +0300
+++ mariadb-10.0.20.new/include/my_pthread.h	2015-10-03 00:12:46.000000000 +0300
@@ -142,9 +142,33 @@ int pthread_cancel(pthread_t thread);
 
 #define pthread_equal(A,B) ((A) == (B))
 #define pthread_mutex_init(A,B)  (InitializeCriticalSection(A),0)
-#define pthread_mutex_lock(A)	 (EnterCriticalSection(A),0)
-#define pthread_mutex_trylock(A) win_pthread_mutex_trylock((A))
-#define pthread_mutex_unlock(A)  (LeaveCriticalSection(A), 0)
+
+int put_in_lve(char *user);
+void lve_thr_exit();
+void governor_setlve_mysql_thread_info(pid_t thread_id);
+void governor_detroy_mysql_thread_info();
+int send_to_client_debug_data_lvedebug_info(void *buffer, int max_size);
+long get_memusage_lvedebug_info();
+void create_core_dump_lvedebug_info();
+void *init_info_retarray_lvedbug_info(int size);
+void release_info_retarray_lvedbug_info(void *ptr);
+void retinfo_info_retarray_lvedbug_info(char *buffer, int field, void *data, int index, int buf_len);
+void release_thread_chanks_lvedebug_info();
+void make_snapshot_lvedebug_info(long number_of_in, long numbers_of_out,
+	int real_lve, void *mysql_lve_mutex_governor_ptr_n, char *fname,
+	void *mtx);
+void init_data_lvedebug_info(char *sql, char *user_name);
+void free_lvedebug_info();
+int initialize_lvedebug_info();
+__attribute__ ((noinline)) int my_pthread_lvemutex_unlock(pthread_mutex_t *mutex);
+__attribute__ ((noinline)) int my_pthread_lvemutex_lock(my_pthread_fastmutex_t *mp);
+__attribute__ ((noinline)) int my_pthread_lvemutex_trylock(pthread_mutex_t *mutex);
+__attribute__((noinline)) void my_release_slot();
+__attribute__((noinline)) void my_reserve_slot();
+#define pthread_mutex_lock(A) my_pthread_lvemutex_lock(A)
+#define pthread_mutex_unlock(A) my_pthread_lvemutex_unlock(&(A)->mutex)
+#define pthread_mutex_trylock(A) my_pthread_lvemutex_trylock(&(A)->mutex)
+
 #define pthread_mutex_destroy(A) (DeleteCriticalSection(A), 0)
 #define pthread_kill(A,B) pthread_dummy((A) ? 0 : ESRCH)
 
@@ -165,6 +189,7 @@ int pthread_cancel(pthread_t thread);
 #include <signal.h>
 #undef sigwait
 #endif
+#include <governor.h>
 #include <pthread.h>
 #ifndef _REENTRANT
 #define _REENTRANT
@@ -408,6 +433,26 @@ typedef struct st_safe_mutex_info_t
 } safe_mutex_info_t;
 #endif /* SAFE_MUTEX_DETECT_DESTROY */
 
+int put_in_lve(char *user);
+void lve_thr_exit();
+void governor_setlve_mysql_thread_info(pid_t thread_id);
+void governor_detroy_mysql_thread_info();
+int send_to_client_debug_data_lvedebug_info(void *buffer, int max_size);
+long get_memusage_lvedebug_info();
+void create_core_dump_lvedebug_info();
+void *init_info_retarray_lvedbug_info(int size);
+void release_info_retarray_lvedbug_info(void *ptr);
+void retinfo_info_retarray_lvedbug_info(char *buffer, int field, void *data, int index, int buf_len);
+void release_thread_chanks_lvedebug_info();
+void make_snapshot_lvedebug_info(long number_of_in, long numbers_of_out,
+	int real_lve, void *mysql_lve_mutex_governor_ptr_n, char *fname,
+	void *mtx);
+void init_data_lvedebug_info(char *sql, char *user_name);
+void free_lvedebug_info();
+int initialize_lvedebug_info();
+__attribute__((noinline)) void my_release_slot();
+__attribute__((noinline)) void my_reserve_slot();
+
 int safe_mutex_init(safe_mutex_t *mp, const pthread_mutexattr_t *attr,
                     const char *name, const char *file, uint line);
 int safe_mutex_lock(safe_mutex_t *mp, myf my_flags, const char *file,
diff -rupN mariadb-10.0.20.old/mysys/CMakeLists.txt mariadb-10.0.20.new/mysys/CMakeLists.txt
--- mariadb-10.0.20.old/mysys/CMakeLists.txt	2015-06-17 17:54:12.000000000 +0300
+++ mariadb-10.0.20.new/mysys/CMakeLists.txt	2015-09-27 22:49:38.000000000 +0300
@@ -69,7 +69,7 @@ ENDIF()
 
 ADD_CONVENIENCE_LIBRARY(mysys ${MYSYS_SOURCES})
 TARGET_LINK_LIBRARIES(mysys dbug strings ${ZLIB_LIBRARY} 
- ${LIBNSL} ${LIBM} ${LIBRT} ${LIBSOCKET} ${LIBEXECINFO})
+ ${LIBNSL} ${LIBM} ${LIBRT} ${LIBSOCKET} ${LIBEXECINFO} dl)
 DTRACE_INSTRUMENT(mysys)
 
 IF(HAVE_BFD_H)
@@ -82,7 +82,7 @@ ENDIF(WIN32)
 
 # Need explicit pthread for gcc -fsanitize=address
 IF(CMAKE_USE_PTHREADS_INIT AND CMAKE_C_FLAGS MATCHES "-fsanitize=")
-  TARGET_LINK_LIBRARIES(mysys pthread)
+  TARGET_LINK_LIBRARIES(mysys pthread dl)
 ENDIF()
 
 ADD_EXECUTABLE(thr_lock thr_lock.c)
diff -rupN mariadb-10.0.20.old/mysys/thr_mutex.c mariadb-10.0.20.new/mysys/thr_mutex.c
--- mariadb-10.0.20.old/mysys/thr_mutex.c	2015-06-17 17:54:12.000000000 +0300
+++ mariadb-10.0.20.new/mysys/thr_mutex.c	2015-10-26 15:41:15.000000000 +0200
@@ -27,11 +27,16 @@
 #undef SAFE_MUTEX                       /* Avoid safe_mutex redefinitions */
 #endif
 
+#include <linux/unistd.h>
+
 #include "mysys_priv.h"
 #include "my_static.h"
 #include <m_string.h>
 #include <hash.h>
 
+#include <execinfo.h>
+#include <syslog.h>
+
 #ifndef DO_NOT_REMOVE_THREAD_WRAPPERS
 /* Remove wrappers */
 #undef pthread_mutex_t
@@ -53,6 +58,99 @@ pthread_mutexattr_t my_errorcheck_mutexa
 #endif
 
 #ifdef SAFE_MUTEX_DEFINED
+
+void * (*governor_load_lve_library)() = NULL;
+int (*governor_init_lve)() = NULL;
+void (*governor_destroy_lve)() = NULL;
+int (*governor_enter_lve)(uint32_t *, char *) = NULL;
+void (*governor_lve_exit)(uint32_t *) = NULL;
+int (*governor_enter_lve_light)(uint32_t *) = NULL;
+void (*governor_lve_exit_null)() = NULL;
+int (*governor_lve_enter_pid)(pid_t) = NULL;
+int (*governor_is_in_lve)() = NULL;
+ 
+void governor_setlve_mysql_thread_info(pid_t thread_id) {
+       (void)(thread_id);
+       return;
+}
+
+__attribute__((noinline)) int put_in_lve(char *user) {
+       (void)(user);
+       return 0;
+}
+
+__attribute__((noinline)) void lve_thr_exit() {
+       return;
+}
+
+void governor_detroy_mysql_thread_info(){
+       return;
+}
+
+__attribute__((noinline)) void my_release_slot(){
+    return;
+}
+
+__attribute__((noinline)) void my_reserve_slot(){
+    return;
+}
+
+void create_core_dump_lvedebug_info(){
+    return;
+}
+void release_thread_chanks_lvedebug_info(){
+    return;
+}
+void make_snapshot_lvedebug_info(long number_of_in, long numbers_of_out,
+	int real_lve, void *mysql_lve_mutex_governor_ptr_n, char *fname,
+	void *mtx){
+    (void)(number_of_in);
+    (void)(numbers_of_out);
+    (void)(real_lve);
+    (void)(mysql_lve_mutex_governor_ptr_n);
+    (void)(fname);
+    (void)(mtx);
+    return;
+}
+void init_data_lvedebug_info(char *sql, char *user_name){
+    (void)(sql);
+    (void)(user_name);
+    return;
+}
+void free_lvedebug_info(){
+    return;
+}
+int initialize_lvedebug_info(){
+    return 0;
+}
+
+int send_to_client_debug_data_lvedebug_info(char *buffer, int max_size) {
+	(void)(buffer);
+	(void)(max_size);
+	return 0;
+}
+
+long get_memusage_lvedebug_info() {
+	return 0;
+}
+
+void *init_info_retarray_lvedbug_info(int size){
+	(void)(size);
+	return NULL;
+}
+
+void release_info_retarray_lvedbug_info(void *ptr){
+	(void)(ptr);
+}
+
+void retinfo_info_retarray_lvedbug_info(char *buffer, int field, void *data, int index, int buf_len){
+	(void)(buffer);
+	(void)(field);
+	(void)(data);
+	(void)(index);
+	(void)(buf_len);
+}
+
 static pthread_mutex_t THR_LOCK_mutex;
 static ulong safe_mutex_count= 0;		/* Number of mutexes created */
 static ulong safe_mutex_id= 0;
@@ -914,6 +1012,901 @@ int my_pthread_fastmutex_lock(my_pthread
   return pthread_mutex_lock(&mp->mutex);
 }
 
+/*
+ * List of functions which will be imported from libgovernor
+ * to work with LVE
+ */
+void * (*governor_load_lve_library)() = NULL; //load library by dl and initialize all pointers to fuctions
+int (*governor_init_lve)() = NULL; //init_lve wrapper
+void (*governor_destroy_lve)() = NULL; //destroy_lve wrapper
+int (*governor_enter_lve)(uint32_t *, char *) = NULL; //lve_enter wrapper
+void (*governor_lve_exit)(uint32_t *) = NULL; // lve_leave wrapper
+int (*governor_enter_lve_light)(uint32_t *) = NULL; // lve_enter with stored pcookie and UID in thread storage
+void (*governor_lve_exit_null)() = NULL; //lve_exit with NULL cookie (not used yet)
+int (*governor_lve_enter_pid)(pid_t) = NULL; //lve_enter_pid for entering another thread (not used yet)
+int (*governor_is_in_lve)() = NULL; //is_in_lve - for checking is thread in LVE, only for debug purpocess
+
+//extern CHARSET_INFO my_charset_latin1_bin;
+CHARSET_INFO governor_charset_bin;
+
+//Thread dependent variable for thread cookie storage needs for governor_enter_lve, governor_lve_exit
+__thread uint32_t lve_cookie = 0;
+
+//Mutex for checking access to
+pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
+
+typedef struct __mysql_mutex {
+       pid_t *key; //thread_id
+       int is_in_lve; //
+       int is_in_mutex; //mutex_lock count
+       int put_in_lve; //
+       int was_in_lve; //
+} mysql_mutex;
+
+static HASH *mysql_lve_mutex_governor = NULL;
+
+__thread mysql_mutex *mysql_lve_mutex_governor_ptr = 0;
+
+pthread_mutex_t mtx_mysql_lve_mutex_governor_ptr = PTHREAD_MUTEX_INITIALIZER;
+
+//Insert debug part begin
+#define LVEMUTEX_USER_MAXSIZE 64
+#define LVEMUTEX_SQL_MAXSIZE 2048
+#define LVEMUTEX_OUT_MAXSIZE 4000
+#define LVEMUTEX_OUT_LOG_NAME "debug_info.log"
+#define LVEMUTEX_OUT_CONF_NAME "/etc/my.debug.conf"
+#define LVEMUTEX_OUT_CORE_NAME "debug_core_file"
+
+typedef long atomic_long;
+
+typedef struct __mysql_mutex_info_runtime_out {
+	char chunk_to_out[LVEMUTEX_OUT_MAXSIZE];
+	long size;
+	time_t tm;
+	struct __mysql_mutex_info_runtime_out *next;
+} mysql_mutex_info_runtime_out;
+
+typedef struct __mysql_mutex_info_runtime {
+	pid_t init_therad_id;
+	char sql_req[LVEMUTEX_SQL_MAXSIZE];
+	char user_name[LVEMUTEX_USER_MAXSIZE];
+	long number_of_in;
+	long numbers_of_out;
+	long max_mutex_deap;
+	int init;
+	mysql_mutex_info_runtime_out *chunk_ptr;
+	mysql_mutex_info_runtime_out *chunk_ptr_tail;
+} mysql_mutex_info_runtime;
+
+typedef struct __mysql_online_statistic_lvedebug_info {
+	pid_t pid;
+	int is_in_lve;
+	int chk_is_in_lve;
+	char debug_info[LVEMUTEX_OUT_MAXSIZE];
+	char sql[LVEMUTEX_OUT_MAXSIZE];
+	pthread_mutex_t flag_m;
+	void *ptr;
+} mysql_online_statistic_lvedebug_info;
+
+typedef struct __mysql_online_statistic_lvedebug_info_list {
+	mysql_online_statistic_lvedebug_info *ptr;
+	long size;
+	struct __mysql_online_statistic_lvedebug_info_list *next;
+	struct __mysql_online_statistic_lvedebug_info_list *prev;
+} mysql_online_statistic_lvedebug_info_list;
+
+typedef struct __mysql_mutex_info {
+	int debug_level; //0 - disbaled, 1-just in memory, 2 - write to one file, 3 - write to separate files, 4 - write to syslog
+	char user_to_debug[LVEMUTEX_USER_MAXSIZE];
+	int use_check; //0 - no, 1 - yes(call is_in_lve for flag checking)
+	char path_to_save[LVEMUTEX_SQL_MAXSIZE]; //where files will be saved
+	FILE *log_fd; //one file mode descriptor
+	pid_t pid; //parent pid
+	void *core;
+	int (*WriteCoreDump)(const char *);
+	int frame_deep;
+	long max_mem;
+	atomic_long current_usage;
+	pthread_mutex_t lock;
+	mysql_online_statistic_lvedebug_info_list *head;
+	mysql_online_statistic_lvedebug_info_list *tail;
+} mysql_mutex_info;
+
+typedef struct __mysql_online_statistic_lvedebug_info_ret {
+	pid_t pid;
+	int is_in_lve;
+	int chk_is_in_lve;
+	char debug_info[LVEMUTEX_OUT_MAXSIZE];
+	char sql[LVEMUTEX_OUT_MAXSIZE];
+} mysql_online_statistic_lvedebug_info_ret;
+
+static mysql_mutex_info lve_options_storage = { 0 };
+
+static pthread_mutex_t fd_mtx = PTHREAD_MUTEX_INITIALIZER;
+static pthread_mutex_t fd_dump = PTHREAD_MUTEX_INITIALIZER;
+static __thread mysql_mutex_info_runtime debug_info_storage = { 0 };
+static __thread mysql_online_statistic_lvedebug_info current_debug_info = { 0 };
+
+void *init_info_retarray_lvedbug_info(int size){
+	mysql_online_statistic_lvedebug_info_ret *ptr = calloc(size, sizeof(mysql_online_statistic_lvedebug_info_ret));
+	return (void *)ptr;
+}
+
+void release_info_retarray_lvedbug_info(void *ptr){
+	if(ptr) free(ptr);
+}
+
+void retinfo_info_retarray_lvedbug_info(char *buffer, int field, void *data, int index, int buf_len){
+	mysql_online_statistic_lvedebug_info_ret *ptr = (mysql_online_statistic_lvedebug_info_ret *)data;
+	if(ptr){
+		ptr += index;
+		switch(field){
+		case 0:
+			snprintf(buffer, buf_len, "%d", ptr->pid);
+			break;
+		case 1:
+			snprintf(buffer, buf_len, "%d", ptr->is_in_lve);
+			break;
+		case 2:
+			snprintf(buffer, buf_len, "%d", ptr->chk_is_in_lve);
+			break;
+		case 3:
+			snprintf(buffer, buf_len, "%s", ptr->sql);
+			break;
+		case 4:
+			snprintf(buffer, buf_len, "%s", ptr->debug_info);
+			break;
+		}
+	}
+
+}
+
+static void *try_to_calloc_lvedebug_info(size_t __nmemb, size_t __size) {
+	void *result_ptr = NULL;
+	long tmp_size = __nmemb * __size;
+	if (__sync_sub_and_fetch(&lve_options_storage.current_usage, 0) >= 0) {
+		result_ptr = calloc(__nmemb, __size);
+		if (result_ptr) {
+			__sync_sub_and_fetch(&lve_options_storage.current_usage, tmp_size);
+			((mysql_mutex_info_runtime_out *) result_ptr)->size = (__nmemb
+					* __size);
+		}
+	}
+	return result_ptr;
+}
+
+static void try_to_free_lvedebug_info(void *ptr) {
+	mysql_mutex_info_runtime_out *ptr_tmp =
+			(mysql_mutex_info_runtime_out *) ptr;
+	if(ptr_tmp){
+		__sync_add_and_fetch(&lve_options_storage.current_usage, ptr_tmp->size);
+		free(ptr_tmp);
+	}
+}
+
+static void *try_to_calloc_lvedebug_info_(size_t __nmemb, size_t __size) {
+	void *result_ptr = NULL;
+	long tmp_size = __nmemb * __size;
+	if (__sync_sub_and_fetch(&lve_options_storage.current_usage, 0) >= 0) {
+		result_ptr = calloc(__nmemb, __size);
+		if (result_ptr) {
+			__sync_sub_and_fetch(&lve_options_storage.current_usage, tmp_size);
+			((mysql_online_statistic_lvedebug_info_list *) result_ptr)->size
+					= (__nmemb * __size);
+		}
+	}
+	return result_ptr;
+}
+
+static void try_to_free_lvedebug_info_(void *ptr) {
+	mysql_online_statistic_lvedebug_info_list *ptr_tmp =
+			(mysql_online_statistic_lvedebug_info_list *) ptr;
+	if(ptr_tmp){
+		__sync_add_and_fetch(&lve_options_storage.current_usage, ptr_tmp->size);
+		free(ptr_tmp);
+	}
+}
+
+static void read_config_lvedebug_info() {
+	char read_buff[LVEMUTEX_SQL_MAXSIZE] = { 0 };
+	FILE *fp = fopen(LVEMUTEX_OUT_CONF_NAME, "r");
+	if (fp) {
+		while (fgets(read_buff, LVEMUTEX_SQL_MAXSIZE, fp) != NULL) {
+			if (read_buff[strnlen(read_buff, LVEMUTEX_SQL_MAXSIZE) - 1] == 0xA) {
+				read_buff[strnlen(read_buff, LVEMUTEX_SQL_MAXSIZE) - 1] = 0;
+			}
+			if (strstr(read_buff, "debug_level")) {
+				char *ptr = strchr(read_buff, '=');
+				if (ptr) {
+					ptr++;
+					lve_options_storage.debug_level = atoi(ptr);
+				}
+			}
+			if (strstr(read_buff, "user_to_debug")) {
+				char *ptr = strchr(read_buff, '=');
+				if (ptr) {
+					ptr++;
+					strncpy(lve_options_storage.user_to_debug, ptr, LVEMUTEX_USER_MAXSIZE-1);
+				}
+			}
+			if (strstr(read_buff, "path_to_save")) {
+				char *ptr = strchr(read_buff, '=');
+				if (ptr) {
+					ptr++;
+					strncpy(lve_options_storage.path_to_save, ptr, LVEMUTEX_SQL_MAXSIZE-1);
+				}
+			}
+			if (strstr(read_buff, "use_check")) {
+				char *ptr = strchr(read_buff, '=');
+				if (ptr) {
+					ptr++;
+					lve_options_storage.use_check = atoi(ptr);
+				}
+			}
+			if (strstr(read_buff, "frame_deep")) {
+				char *ptr = strchr(read_buff, '=');
+				if (ptr) {
+					ptr++;
+					lve_options_storage.frame_deep = atoi(ptr);
+				}
+			}
+			if (strstr(read_buff, "max_memory")) {
+				char *ptr = strchr(read_buff, '=');
+				if (ptr) {
+					ptr++;
+					lve_options_storage.max_mem = atol(ptr);
+				}
+			}
+		}
+		fclose(fp);
+	}
+}
+
+static pid_t gettid_lvedebug_info(void) {
+	return syscall(__NR_gettid);
+}
+
+int initialize_lvedebug_info() {
+	int error_res = 0;
+	char file_path_buffer[LVEMUTEX_OUT_MAXSIZE];
+	memset(&lve_options_storage, (int) 0, sizeof(mysql_mutex_info));
+	strcpy(lve_options_storage.path_to_save, "/tmp");
+	lve_options_storage.frame_deep = 10;
+	lve_options_storage.max_mem = 100 * 1024 * 1024;
+	lve_options_storage.current_usage = lve_options_storage.max_mem;
+	read_config_lvedebug_info();
+	pthread_mutex_lock(&fd_mtx);
+	if (lve_options_storage.debug_level && !lve_options_storage.log_fd) {
+		lve_options_storage.pid = getpid();
+		snprintf(file_path_buffer, LVEMUTEX_OUT_MAXSIZE, "%s/%s.%d",
+				lve_options_storage.path_to_save, LVEMUTEX_OUT_LOG_NAME,
+				lve_options_storage.pid);
+		lve_options_storage.log_fd = fopen(file_path_buffer, "a");
+		if (lve_options_storage.log_fd == NULL) {
+			lve_options_storage.debug_level = 0;
+			error_res = 1;
+		}
+		lve_options_storage.core = dlopen("libcoredumper.so.1",
+				RTLD_LOCAL | RTLD_LAZY);
+		if (lve_options_storage.core) {
+			lve_options_storage.WriteCoreDump = dlsym(lve_options_storage.core,
+					"WriteCoreDump");
+			if (!lve_options_storage.WriteCoreDump) {
+				dlclose(lve_options_storage.core);
+				lve_options_storage.core = NULL;
+			}
+		}
+	}
+	pthread_mutex_unlock(&fd_mtx);
+	if (error_res)
+		return -1;
+	else
+		return 0;
+}
+
+static void release_current_info_lvedebug_info() {
+	pthread_mutex_lock(&lve_options_storage.lock);
+	if (lve_options_storage.head) {
+		mysql_online_statistic_lvedebug_info_list *ptr =
+				lve_options_storage.head;
+		while (ptr) {
+			mysql_online_statistic_lvedebug_info_list *ptr_tmp = ptr;
+			ptr = ptr->next;
+			try_to_free_lvedebug_info_(ptr_tmp);
+		}
+		lve_options_storage.head = NULL;
+		lve_options_storage.tail = NULL;
+	}
+	pthread_mutex_unlock(&lve_options_storage.lock);
+}
+
+void free_lvedebug_info() {
+	if (lve_options_storage.debug_level) {
+		pthread_mutex_lock(&fd_mtx);
+		if (lve_options_storage.log_fd) {
+			fflush(lve_options_storage.log_fd);
+			fclose(lve_options_storage.log_fd);
+			lve_options_storage.pid = 0;
+			if (lve_options_storage.core) {
+				dlclose(lve_options_storage.core);
+				lve_options_storage.core = NULL;
+				lve_options_storage.WriteCoreDump = NULL;
+			}
+		}
+		pthread_mutex_unlock(&fd_mtx);
+		release_current_info_lvedebug_info();
+	}
+}
+
+static void set_current_info_lvedebug_info(int first, char *sql,
+		char *debug_info, int is_in_lve, int check_is_in_lve) {
+	pthread_mutex_lock(&current_debug_info.flag_m);
+	if (first) {
+		current_debug_info.chk_is_in_lve = check_is_in_lve;
+		current_debug_info.is_in_lve = is_in_lve;
+		current_debug_info.pid = gettid_lvedebug_info();
+		current_debug_info.ptr = NULL;
+		strncpy(current_debug_info.debug_info, debug_info,
+				sizeof(current_debug_info.debug_info)-1);
+		strncpy(current_debug_info.sql, sql, sizeof(current_debug_info.sql)-1);
+
+		mysql_online_statistic_lvedebug_info_list *ptr =
+				try_to_calloc_lvedebug_info_(1,
+						sizeof(mysql_online_statistic_lvedebug_info_list));
+		if (ptr) {
+			current_debug_info.ptr = ptr;
+			ptr->ptr = &current_debug_info;
+			pthread_mutex_lock(&lve_options_storage.lock);
+			if (!lve_options_storage.tail) {
+				lve_options_storage.tail = ptr;
+				lve_options_storage.head = ptr;
+			} else {
+				lve_options_storage.tail->next = ptr;
+				ptr->prev = lve_options_storage.tail;
+				lve_options_storage.tail = ptr;
+			}
+			pthread_mutex_unlock(&lve_options_storage.lock);
+		}
+
+	} else {
+
+		current_debug_info.chk_is_in_lve = check_is_in_lve;
+		current_debug_info.is_in_lve = is_in_lve;
+		strncpy(current_debug_info.debug_info, debug_info,
+				sizeof(current_debug_info.debug_info));
+
+	}
+	pthread_mutex_unlock(&current_debug_info.flag_m);
+}
+
+static void remove_current_info_lvedebug_info() {
+	if (current_debug_info.ptr) {
+		pthread_mutex_lock(&lve_options_storage.lock);
+		mysql_online_statistic_lvedebug_info_list
+				*i_ptr =
+						(mysql_online_statistic_lvedebug_info_list *) current_debug_info.ptr;
+		if (i_ptr->prev) {
+			i_ptr->prev->next = i_ptr->next;
+		} else {
+			lve_options_storage.head = i_ptr->next;
+		}
+		if (i_ptr->next) {
+			i_ptr->next->prev = i_ptr->prev;
+		} else {
+			lve_options_storage.tail = i_ptr->prev;
+		}
+		pthread_mutex_unlock(&lve_options_storage.lock);
+		try_to_free_lvedebug_info_(current_debug_info.ptr);
+		current_debug_info.ptr = NULL;
+	}
+}
+
+static int save_data_to_file_lvedebug_info(mysql_mutex_info_runtime_out *chanks) {
+	char path_to_save[LVEMUTEX_OUT_MAXSIZE] = { 0 };
+	char buffer[80];
+	FILE *i_fd = NULL;
+	if (chanks && (lve_options_storage.debug_level >= 2)) {
+		if (lve_options_storage.debug_level == 2) {
+			i_fd = lve_options_storage.log_fd;
+			pthread_mutex_lock(&fd_mtx);
+		} else if (lve_options_storage.debug_level == 4) {
+			i_fd = NULL;
+		} else {
+			snprintf(path_to_save, LVEMUTEX_OUT_MAXSIZE, "%s/%s.%d.%d",
+					lve_options_storage.path_to_save, LVEMUTEX_OUT_LOG_NAME,
+					lve_options_storage.pid, gettid_lvedebug_info());
+			i_fd = fopen(path_to_save, "a");
+			if (i_fd == NULL) {
+				return -1;
+			}
+		}
+
+		mysql_mutex_info_runtime_out *ptr = chanks;
+		while (ptr) {
+			if (i_fd == NULL) {
+				openlog ("mysqld_debug", LOG_PID | LOG_NDELAY, LOG_DAEMON);
+				syslog (LOG_DEBUG, ptr->chunk_to_out);
+
+				closelog ();
+			} else {
+				struct tm *info;
+				info = localtime(&ptr->tm);
+				strftime(buffer, 80, "%c", info);
+				fprintf(i_fd, "%s: %s\n", buffer, ptr->chunk_to_out);
+			}
+			ptr = ptr->next;
+		}
+
+		if (lve_options_storage.debug_level == 2) {
+			fflush(i_fd);
+			pthread_mutex_unlock(&fd_mtx);
+		} else if (lve_options_storage.debug_level == 4) {
+			i_fd = NULL;
+		} else {
+			fflush(i_fd);
+			fclose(i_fd);
+		}
+	}
+	return 0;
+}
+
+void init_data_lvedebug_info(char *sql, char *user_name) {
+	if (lve_options_storage.debug_level) {
+		memset(&debug_info_storage, 0, sizeof(debug_info_storage));
+		strncpy(debug_info_storage.sql_req, sql, LVEMUTEX_SQL_MAXSIZE-1);
+		strncpy(debug_info_storage.user_name, user_name, LVEMUTEX_USER_MAXSIZE-1);
+		set_current_info_lvedebug_info(1, debug_info_storage.sql_req, "INIT",
+				0, -1);
+	}
+}
+
+void create_core_dump_lvedebug_info() {
+	//Don't call in LVE
+	char path_to_save[LVEMUTEX_OUT_MAXSIZE] = { 0 };
+
+	snprintf(path_to_save, LVEMUTEX_OUT_MAXSIZE, "%s/%s.%d.%d",
+			lve_options_storage.path_to_save, LVEMUTEX_OUT_CORE_NAME,
+			lve_options_storage.pid, current_debug_info.pid);
+	if (lve_options_storage.WriteCoreDump) {
+		pthread_mutex_lock(&fd_dump);
+		(*lve_options_storage.WriteCoreDump)(path_to_save);
+		pthread_mutex_unlock(&fd_dump);
+	}
+}
+
+static void flush_data_lvedebug_info() {
+	if (debug_info_storage.chunk_ptr) {
+		save_data_to_file_lvedebug_info(debug_info_storage.chunk_ptr);
+	}
+	mysql_mutex_info_runtime_out *ptr = debug_info_storage.chunk_ptr;
+	while (ptr) {
+		mysql_mutex_info_runtime_out *ptr2 = ptr;
+		ptr = ptr->next;
+		try_to_free_lvedebug_info(ptr2);
+	}
+	debug_info_storage.chunk_ptr = NULL;
+	debug_info_storage.chunk_ptr_tail = NULL;
+}
+
+void make_snapshot_lvedebug_info(long number_of_in, long numbers_of_out,
+		int real_lve, void *mysql_lve_mutex_governor_ptr_n, char *fname,
+		void *mtx) {
+	int real_lve_i = -1;
+	(mysql_mutex *) (mysql_lve_mutex_governor_ptr_n);
+
+	if (mysql_lve_mutex_governor_ptr && lve_options_storage.debug_level) {
+		if (lve_options_storage.use_check) {
+			if (governor_is_in_lve) {
+				real_lve_i = governor_is_in_lve();
+			}
+		}
+
+		char snapshot_buf_ss[LVEMUTEX_OUT_MAXSIZE] = { 0 };
+		char snapshot_buf_ss2[LVEMUTEX_OUT_MAXSIZE] = { 0 };
+		debug_info_storage.number_of_in += number_of_in;
+		debug_info_storage.numbers_of_out += numbers_of_out;
+		if (debug_info_storage.max_mutex_deap
+				< mysql_lve_mutex_governor_ptr->is_in_mutex)
+			debug_info_storage.max_mutex_deap
+					= mysql_lve_mutex_governor_ptr->is_in_mutex;
+		void *array[10];
+		int size;
+		char **strings;
+		size_t i;
+		size = backtrace(array, lve_options_storage.frame_deep * 3);
+		strings = backtrace_symbols(array, size);
+		for (i = (((size - lve_options_storage.frame_deep) < 0) ? 0 : (size
+				- lve_options_storage.frame_deep)); i < size; i++) {
+			snprintf(snapshot_buf_ss2, LVEMUTEX_OUT_MAXSIZE-1, "%s # %s|",
+					snapshot_buf_ss, strings[i]);
+			strncpy(snapshot_buf_ss, snapshot_buf_ss2, LVEMUTEX_OUT_MAXSIZE);
+		}
+		free(strings);
+		set_current_info_lvedebug_info(0, "SQL", snapshot_buf_ss,
+				mysql_lve_mutex_governor_ptr->is_in_lve, real_lve_i);
+		if (!debug_info_storage.init) {
+			debug_info_storage.init = 1;
+
+			mysql_mutex_info_runtime_out *ptr = try_to_calloc_lvedebug_info(1,
+					sizeof(mysql_mutex_info_runtime_out));
+			if (ptr) {
+				ptr->tm = time(NULL);
+				snprintf(ptr->chunk_to_out, LVEMUTEX_OUT_MAXSIZE,
+						"%d %s SQL %s U:%s", gettid_lvedebug_info(), fname,
+						debug_info_storage.sql_req,
+						debug_info_storage.user_name);
+				if (debug_info_storage.chunk_ptr_tail) {
+					debug_info_storage.chunk_ptr_tail->next = ptr;
+					debug_info_storage.chunk_ptr_tail = ptr;
+				} else {
+					debug_info_storage.chunk_ptr = ptr;
+					debug_info_storage.chunk_ptr_tail = ptr;
+				}
+			}
+
+		}
+
+		if (lve_options_storage.debug_level > 1) {
+			mysql_mutex_info_runtime_out *ptr = try_to_calloc_lvedebug_info(1,
+					sizeof(mysql_mutex_info_runtime_out));
+			if (ptr) {
+				ptr->tm = time(NULL);
+				snprintf(
+						ptr->chunk_to_out,
+						LVEMUTEX_OUT_MAXSIZE,
+						"%d %s IN %ld OUT %ld MD %ld IILR %d FL %d PL %d M:%p %s",
+						gettid_lvedebug_info(), fname,
+						debug_info_storage.number_of_in,
+						debug_info_storage.numbers_of_out,
+						debug_info_storage.max_mutex_deap, real_lve_i,
+						mysql_lve_mutex_governor_ptr->is_in_lve,
+						mysql_lve_mutex_governor_ptr->put_in_lve, mtx,
+						snapshot_buf_ss);
+				if (debug_info_storage.chunk_ptr_tail) {
+					debug_info_storage.chunk_ptr_tail->next = ptr;
+					debug_info_storage.chunk_ptr_tail = ptr;
+				} else {
+					debug_info_storage.chunk_ptr = ptr;
+					debug_info_storage.chunk_ptr_tail = ptr;
+				}
+			}
+		}
+
+		if (real_lve && lve_options_storage.use_check) {
+			if (((real_lve_i == 1)
+					&& (mysql_lve_mutex_governor_ptr->is_in_lve != 1))
+					|| ((real_lve_i == 0)
+							&& (mysql_lve_mutex_governor_ptr->is_in_lve == 1))) {
+				flush_data_lvedebug_info();
+				create_core_dump_lvedebug_info();
+			}
+		}
+
+	}
+}
+
+void release_thread_chanks_lvedebug_info() {
+	if (lve_options_storage.debug_level) {
+		remove_current_info_lvedebug_info();
+		if (debug_info_storage.chunk_ptr) {
+			save_data_to_file_lvedebug_info(debug_info_storage.chunk_ptr);
+		}
+		mysql_mutex_info_runtime_out *ptr = debug_info_storage.chunk_ptr;
+		while (ptr) {
+			mysql_mutex_info_runtime_out *ptr2 = ptr;
+			ptr = ptr->next;
+			try_to_free_lvedebug_info(ptr2);
+		}
+		debug_info_storage.chunk_ptr = NULL;
+		debug_info_storage.chunk_ptr_tail = NULL;
+	}
+}
+
+static void get_core_lvedebug_info(void *mysql_lve_mutex_governor_ptr_n) {
+	int real_lve_i = -1;
+	mysql_mutex *mysql_lve_mutex_governor_ptr_i =
+			(mysql_mutex *) mysql_lve_mutex_governor_ptr_n;
+	if (mysql_lve_mutex_governor_ptr_i && lve_options_storage.debug_level) {
+		if (lve_options_storage.use_check) {
+			if (governor_is_in_lve) {
+				real_lve_i = governor_is_in_lve();
+			}
+			if (((real_lve_i == 1)
+					&& (mysql_lve_mutex_governor_ptr_i->is_in_lve != 1))
+					|| ((real_lve_i == 0)
+							&& (mysql_lve_mutex_governor_ptr_i->is_in_lve == 1))) {
+				create_core_dump_lvedebug_info();
+			}
+		}
+	}
+}
+
+int send_to_client_debug_data_lvedebug_info(void *buffer, int max_size) {
+	int counter = max_size;
+
+	mysql_online_statistic_lvedebug_info_ret *buffer_i = (mysql_online_statistic_lvedebug_info_ret *)buffer;
+	if(!buffer_i) return 0;
+	pthread_mutex_lock(&lve_options_storage.lock);
+	if (lve_options_storage.head) {
+		mysql_online_statistic_lvedebug_info_list *ptr =
+				lve_options_storage.head;
+		while (ptr) {
+			if (ptr->ptr) {
+				pthread_mutex_lock(&ptr->ptr->flag_m);
+				(*buffer_i).chk_is_in_lve = ptr->ptr->chk_is_in_lve;
+				(*buffer_i).is_in_lve = ptr->ptr->is_in_lve;
+				(*buffer_i).pid = ptr->ptr->pid;
+				strncpy((*buffer_i).sql, ptr->ptr->sql, LVEMUTEX_OUT_MAXSIZE-1);
+				strncpy((*buffer_i).debug_info, ptr->ptr->debug_info, LVEMUTEX_OUT_MAXSIZE-1);
+				pthread_mutex_unlock(&ptr->ptr->flag_m);
+				buffer_i++;
+				counter--;
+				if (counter == 0)
+					break;
+			}
+			ptr = ptr->next;
+		}
+	}
+	pthread_mutex_unlock(&lve_options_storage.lock);
+	return (max_size - counter);
+}
+
+long get_memusage_lvedebug_info() {
+	return __sync_add_and_fetch(&lve_options_storage.current_usage, 0);
+}
+//Insert debug part end
+
+void governor_value_destroyed(mysql_mutex *data) {
+       free(data);
+}
+
+uchar *governor_get_key_table_mutex(mysql_mutex *table_mutex, size_t *length,
+               my_bool not_used __attribute__((unused))) {
+       *length = sizeof(table_mutex->key);
+       return (uchar*) table_mutex->key;
+}
+
+/*
+ *   RETURN
+ * < 0 s < t
+ * 0   s == t
+ * > 0 s > t
+*/
+int governor_my_strnncoll_8bit_bin(CHARSET_INFO * cs __attribute__((unused)), const uchar *s,
+               size_t slen, const uchar *t, size_t tlen, my_bool t_is_prefix) {
+       int res = 0;
+       pid_t s1 = (pid_t)s, t1 = (pid_t)t;
+       if (s1 < t1)
+               res = -1;
+       else if (s1 == t1)
+               res = 0;
+       else
+               res = 1;
+       return res;
+}
+
+void governor_hash_sort_8bit_bin(CHARSET_INFO *cs __attribute__((unused)),
+                           const uchar *key, size_t len,
+                           ulong *nr1, ulong *nr2)
+{
+  return;
+}
+
+
+/*
+ * Function for create HASH table where will be stored mysql_mutex items for all
+ * threads
+ */
+HASH *governor_create_hash_table() {
+       mysql_lve_mutex_governor = (HASH *) calloc(1, sizeof(HASH));
+       if (mysql_lve_mutex_governor) {
+               memcpy(&governor_charset_bin, &my_charset_latin1_bin,
+                               sizeof(CHARSET_INFO));
+               governor_charset_bin.coll->strnncoll = governor_my_strnncoll_8bit_bin;
+               governor_charset_bin.coll->hash_sort = governor_hash_sort_8bit_bin;
+               if (my_hash_init(mysql_lve_mutex_governor, &governor_charset_bin, 500, 0,
+                               0, (my_hash_get_key) governor_get_key_table_mutex,
+                               (my_hash_free_key) governor_value_destroyed, 0)) {
+                       mysql_lve_mutex_governor = NULL;
+               }
+       }
+       return mysql_lve_mutex_governor;
+}
+
+int governor_add_mysql_thread_info() {
+       pid_t *buf = NULL;
+       pthread_mutex_lock(&mtx_mysql_lve_mutex_governor_ptr);
+       mysql_mutex *mm = NULL;
+       if (!mysql_lve_mutex_governor) {
+               mysql_lve_mutex_governor = governor_create_hash_table();
+               if (!mysql_lve_mutex_governor){
+            	       pthread_mutex_unlock(&mtx_mysql_lve_mutex_governor_ptr);
+                       return -1;
+               }
+       }
+       buf = (pid_t *)syscall(__NR_gettid);
+       mm = (mysql_mutex *) my_hash_search(mysql_lve_mutex_governor,
+                       (uchar *) buf, sizeof(buf));
+       if (!mm) {
+               mm = (mysql_mutex *) calloc(1, sizeof(mysql_mutex));
+               if (!mm){
+            	       pthread_mutex_unlock(&mtx_mysql_lve_mutex_governor_ptr);
+                       return -1;
+               }
+               mm->key = (pid_t *)syscall(__NR_gettid);
+               if (my_hash_insert(mysql_lve_mutex_governor, (uchar *) mm)) {
+                       free(mm);
+                       pthread_mutex_unlock(&mtx_mysql_lve_mutex_governor_ptr);
+                       return -1;
+               }
+       }
+       pthread_mutex_unlock(&mtx_mysql_lve_mutex_governor_ptr);
+       mysql_lve_mutex_governor_ptr = mm;
+       return 0;
+}
+
+void governor_remove_mysql_thread_info() {
+       pid_t *buf = NULL;
+       pthread_mutex_lock(&mtx_mysql_lve_mutex_governor_ptr);
+       mysql_mutex *mm = NULL;
+       if (mysql_lve_mutex_governor) {
+               buf = (pid_t *)syscall(__NR_gettid);
+               mm = (mysql_mutex *) my_hash_search(mysql_lve_mutex_governor,
+                               (uchar *) buf, sizeof(buf));
+               if (mm)
+                       my_hash_delete(mysql_lve_mutex_governor, (uchar *) mm);
+       }
+       pthread_mutex_unlock(&mtx_mysql_lve_mutex_governor_ptr);
+       mysql_lve_mutex_governor_ptr = NULL;
+}
+
+void governor_setlve_mysql_thread_info(pid_t thread_id) {
+       pid_t *buf = NULL;
+       pthread_mutex_lock(&mtx_mysql_lve_mutex_governor_ptr);
+       mysql_mutex *mm = NULL;
+       if (mysql_lve_mutex_governor) {
+               buf = (pid_t *)thread_id;
+               mm = (mysql_mutex *) my_hash_search(mysql_lve_mutex_governor,
+                               (uchar *) buf, sizeof(buf));
+               if (mm) {
+                       if (!mm->is_in_lve) {
+                               mm->put_in_lve = 1;
+                       }
+               }
+       }
+       pthread_mutex_unlock(&mtx_mysql_lve_mutex_governor_ptr);
+}
+
+void governor_detroy_mysql_thread_info() {
+       if (mysql_lve_mutex_governor) {
+               pthread_mutex_lock(&mtx_mysql_lve_mutex_governor_ptr);
+               my_hash_free(mysql_lve_mutex_governor);
+               free(mysql_lve_mutex_governor);
+               pthread_mutex_unlock(&mtx_mysql_lve_mutex_governor_ptr);
+       }
+}
+
+__attribute__((noinline)) int put_in_lve(char *user) {
+       if (governor_add_mysql_thread_info()<0) return -1;
+       if (mysql_lve_mutex_governor_ptr) {
+	       make_snapshot_lvedebug_info(0, 0, 0, mysql_lve_mutex_governor_ptr, "put_in_lve(before)", NULL);
+               if (!governor_enter_lve(&lve_cookie, user)) {
+                       mysql_lve_mutex_governor_ptr->is_in_lve = 1;
+               }
+               mysql_lve_mutex_governor_ptr->is_in_mutex = 0;
+	       make_snapshot_lvedebug_info(0, 0, 0, mysql_lve_mutex_governor_ptr, "put_in_lve", NULL);
+       }
+	
+       return 0;
+}
+
+__attribute__((noinline)) void lve_thr_exit() {
+       if (mysql_lve_mutex_governor_ptr && mysql_lve_mutex_governor_ptr->is_in_lve
+                      == 1) {
+	       get_core_lvedebug_info(mysql_lve_mutex_governor_ptr);
+	       make_snapshot_lvedebug_info(0, 0, 0, mysql_lve_mutex_governor_ptr, "lve_thr_exit(pre exit)", NULL);
+               governor_lve_exit(&lve_cookie);
+               mysql_lve_mutex_governor_ptr->is_in_lve = 0;
+	       make_snapshot_lvedebug_info(0, 0, 0, mysql_lve_mutex_governor_ptr, "lve_thr_exit", NULL);
+       }
+       release_thread_chanks_lvedebug_info();
+       governor_remove_mysql_thread_info();
+}
+
+__attribute__((noinline)) int my_pthread_lvemutex_lock(my_pthread_fastmutex_t *mp) {
+       if (mysql_lve_mutex_governor_ptr) {
+               if (mysql_lve_mutex_governor_ptr->is_in_lve == 1) {
+		       get_core_lvedebug_info(mysql_lve_mutex_governor_ptr);
+                       governor_lve_exit(&lve_cookie);
+                       mysql_lve_mutex_governor_ptr->is_in_lve = 2;
+               } else if (mysql_lve_mutex_governor_ptr->is_in_lve > 1) {
+                       mysql_lve_mutex_governor_ptr->is_in_lve++;
+               }
+               mysql_lve_mutex_governor_ptr->is_in_mutex++;
+	       make_snapshot_lvedebug_info(1, 0, 0, mysql_lve_mutex_governor_ptr, "my_pthread_lvemutex_lock", (void *)&mp->mutex);
+       }
+       return my_pthread_fastmutex_lock(mp);
+}
+
+__attribute__((noinline)) int my_pthread_lvemutex_trylock(pthread_mutex_t *mutex) {
+       if (mysql_lve_mutex_governor_ptr) {
+               if (mysql_lve_mutex_governor_ptr->is_in_lve == 1) {
+			get_core_lvedebug_info(mysql_lve_mutex_governor_ptr);
+                        governor_lve_exit(&lve_cookie);
+               }
+       }
+       int ret = pthread_mutex_trylock(mutex);
+       if (mysql_lve_mutex_governor_ptr) {
+           if (ret != EBUSY){
+                if (mysql_lve_mutex_governor_ptr->is_in_lve == 1) {
+                       mysql_lve_mutex_governor_ptr->is_in_lve = 2;
+                } else if (mysql_lve_mutex_governor_ptr->is_in_lve > 1) {
+                       mysql_lve_mutex_governor_ptr->is_in_lve++;
+                }
+                mysql_lve_mutex_governor_ptr->is_in_mutex++;
+               } else {
+                if (mysql_lve_mutex_governor_ptr->is_in_lve == 1){
+                    if (!governor_enter_lve_light(&lve_cookie)) {
+                           mysql_lve_mutex_governor_ptr->is_in_lve = 1;
+                    } else {
+    			   mysql_lve_mutex_governor_ptr->is_in_lve = 0;
+                    }
+                }
+               }
+	     make_snapshot_lvedebug_info((ret != EBUSY)?1:0, 0, 0, mysql_lve_mutex_governor_ptr, (ret != EBUSY)?"my_pthread_lvemutex_trylock(success)":"my_pthread_lvemutex_trylock(unsuccess)", (void *)mutex);
+       }
+       return ret;
+}
+
+
+__attribute__((noinline)) int my_pthread_lvemutex_unlock(
+               pthread_mutex_t *mutex) {
+       int ret = pthread_mutex_unlock(mutex);
+       if (mysql_lve_mutex_governor_ptr) {
+               if ((mysql_lve_mutex_governor_ptr->is_in_lve == 2)
+                               && governor_enter_lve_light) {
+		       if (!governor_enter_lve_light(&lve_cookie)) {
+                               mysql_lve_mutex_governor_ptr->is_in_lve = 1;
+                       }
+               } else if (mysql_lve_mutex_governor_ptr->is_in_lve > 2) {
+                       mysql_lve_mutex_governor_ptr->is_in_lve--;
+               }
+               mysql_lve_mutex_governor_ptr->is_in_mutex--;
+	       make_snapshot_lvedebug_info(0, 1, 0, mysql_lve_mutex_governor_ptr, "my_pthread_lvemutex_unlock", (void *)mutex);
+       }
+       return ret;
+}
+
+__attribute__((noinline)) void my_reserve_slot() {
+       if (mysql_lve_mutex_governor_ptr) {
+               if (mysql_lve_mutex_governor_ptr->is_in_lve == 1) {
+		       get_core_lvedebug_info(mysql_lve_mutex_governor_ptr);
+                       governor_lve_exit(&lve_cookie);
+                       mysql_lve_mutex_governor_ptr->is_in_lve = 2;
+               } else if (mysql_lve_mutex_governor_ptr->is_in_lve > 1) {
+                       mysql_lve_mutex_governor_ptr->is_in_lve++;
+               }
+               mysql_lve_mutex_governor_ptr->is_in_mutex++;
+	       make_snapshot_lvedebug_info(0, 0, 0, mysql_lve_mutex_governor_ptr, "my_reserve_slot", NULL);
+       }
+       return;
+}
+
+__attribute__((noinline)) void my_release_slot() {
+       if (mysql_lve_mutex_governor_ptr) {
+               if ((mysql_lve_mutex_governor_ptr->is_in_lve == 2)
+                               && governor_enter_lve_light) {
+                        if (!governor_enter_lve_light(&lve_cookie)) {
+                               mysql_lve_mutex_governor_ptr->is_in_lve = 1;
+                       }
+               } else if (mysql_lve_mutex_governor_ptr->is_in_lve > 2) {
+                       mysql_lve_mutex_governor_ptr->is_in_lve--;
+               }
+               mysql_lve_mutex_governor_ptr->is_in_mutex--;
+	       make_snapshot_lvedebug_info(0, 0, 0, mysql_lve_mutex_governor_ptr, "my_release_slot", NULL);
+       }
+       return;
+}
 
 void fastmutex_global_init(void)
 {
diff -rupN mariadb-10.0.20.old/.project mariadb-10.0.20.new/.project
diff -rupN mariadb-10.0.20.old/sql/lex.h mariadb-10.0.20.new/sql/lex.h
--- mariadb-10.0.20.old/sql/lex.h	2015-06-17 17:54:12.000000000 +0300
+++ mariadb-10.0.20.new/sql/lex.h	2015-10-02 18:23:06.000000000 +0300
@@ -205,6 +205,10 @@ static SYMBOL symbols[] = {
   { "ELSE",             SYM(ELSE)},
   { "ELSEIF",           SYM(ELSEIF_SYM)},
   { "ENABLE",		SYM(ENABLE_SYM)},
+  { "ENABLE_GOVERNOR",		SYM(ENABLE_GOVERNOR_SYM)},
+  { "ENABLE_GOVERNOR_RECON",	SYM(ENABLE_GOVERNOR_RECONN_SYM)},
+  { "ENABLE_GOVERNOR_LVE",      SYM(ENABLE_GOVERNOR_LVE_SYM)},
+  { "ENABLE_GOVERNOR_RECON_LVE",  SYM(ENABLE_GOVERNOR_RECONN_LVE_SYM)},
   { "ENCLOSED",		SYM(ENCLOSED)},
   { "END",		SYM(END)},
   { "ENDS",		SYM(ENDS_SYM)},
@@ -338,6 +342,9 @@ static SYMBOL symbols[] = {
   { "LONGTEXT",		SYM(LONGTEXT)},
   { "LOOP",             SYM(LOOP_SYM)},
   { "LOW_PRIORITY",	SYM(LOW_PRIORITY)},
+  { "LVECMD",          SYM(LVECMD_SYM)},
+  { "LVEMEM",          SYM(LVEMEM_SYM)},
+  { "LVEPROCESS",          SYM(LVEPROCESS_SYM)},
   { "MASTER",           SYM(MASTER_SYM)},
   { "MASTER_CONNECT_RETRY",           SYM(MASTER_CONNECT_RETRY_SYM)},
   { "MASTER_GTID_POS",  SYM(MASTER_GTID_POS_SYM)},
diff -rupN mariadb-10.0.20.old/sql/mysqld.cc mariadb-10.0.20.new/sql/mysqld.cc
--- mariadb-10.0.20.old/sql/mysqld.cc	2015-06-17 17:54:12.000000000 +0300
+++ mariadb-10.0.20.new/sql/mysqld.cc	2015-10-02 17:54:55.000000000 +0300
@@ -74,6 +74,9 @@
 #include "sql_callback.h"
 #include "threadpool.h"
 
+#include <dlfcn.h>
+#include <linux/unistd.h>
+
 #ifdef WITH_PERFSCHEMA_STORAGE_ENGINE
 #include "../storage/perfschema/pfs_server.h"
 #endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */
@@ -198,6 +201,10 @@ typedef fp_except fp_except_t;
 #define fcntl(X,Y,Z) 0
 #endif
 
+#ifndef GETTID
+pid_t gettid(void) {return syscall(__NR_gettid);}
+#endif
+
 extern "C" my_bool reopen_fstreams(const char *filename,
                                    FILE *outstream, FILE *errstream);
 
@@ -257,6 +264,29 @@ inline void setup_fpu()
 
 } /* cplusplus */
 
+#ifdef  __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+extern void * (*governor_load_lve_library)();
+extern int (*governor_init_lve)();
+extern void (*governor_destroy_lve)();
+extern int (*governor_enter_lve)(uint32_t *, char *);
+extern int (*governor_enter_lve_light)(uint32_t *);
+extern void (*governor_lve_exit)(uint32_t *);
+extern void (*governor_lve_exit_null)();
+extern int (*governor_lve_enter_pid)(pid_t);
+extern int (*governor_is_in_lve)();
+#ifdef  __cplusplus
+}
+#endif
+
+volatile int governor_get_command = 0;
+int (*connect_to_server)() = NULL;
+int (*send_info_begin)(char *) = NULL;
+int (*send_info_end)(char *) = NULL;
+int (*close_sock)() = NULL;
+void * governor_library_handle = NULL;
+
 #define MYSQL_KILL_SIGNAL SIGTERM
 
 #include <my_pthread.h>			// For thr_setconcurency()
@@ -2052,6 +2082,21 @@ void clean_up(bool print_message)
   free_global_index_stats();
   delete_dynamic(&all_options);
   free_all_rpl_filters();
+
+  governor_detroy_mysql_thread_info();
+
+  if(governor_destroy_lve){
+         governor_destroy_lve();
+  }
+
+  if(close_sock){
+         (*close_sock)();
+  }
+  if (governor_library_handle) {
+         dlclose(governor_library_handle);
+  }
+  free_lvedebug_info();
+
 #ifdef HAVE_REPLICATION
   end_slave_list();
 #endif
@@ -3665,6 +3710,10 @@ SHOW_VAR com_status_vars[]= {
   {"drop_user",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_USER]), SHOW_LONG_STATUS},
   {"drop_view",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_VIEW]), SHOW_LONG_STATUS},
   {"empty_query",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_EMPTY_QUERY]), SHOW_LONG_STATUS},
+  {"enable_governor",      (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ENABLE_GOVERNOR]), SHOW_LONG_STATUS},
+  {"enable_governor_reconn",(char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ENABLE_RECONN_GOVERNOR]), SHOW_LONG_STATUS},
+  {"enable_governor_lve",      (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ENABLE_GOVERNOR_LVE]), SHOW_LONG_STATUS},
+  {"enable_governor_reconn_lve",(char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ENABLE_RECONN_GOVERNOR_LVE]), SHOW_LONG_STATUS},
   {"execute_sql",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_EXECUTE]), SHOW_LONG_STATUS},
   {"flush",                (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_FLUSH]), SHOW_LONG_STATUS},
   {"get_diagnostics",      (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_GET_DIAGNOSTICS]), SHOW_LONG_STATUS},
@@ -3680,6 +3729,7 @@ SHOW_VAR com_status_vars[]= {
   {"kill",                 (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_KILL]), SHOW_LONG_STATUS},
   {"load",                 (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_LOAD]), SHOW_LONG_STATUS},
   {"lock_tables",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_LOCK_TABLES]), SHOW_LONG_STATUS},
+  {"lvecmd",               (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_LVECMD]), SHOW_LONG_STATUS},  
   {"optimize",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_OPTIMIZE]), SHOW_LONG_STATUS},
   {"preload_keys",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_PRELOAD_KEYS]), SHOW_LONG_STATUS},
   {"prepare_sql",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_PREPARE]), SHOW_LONG_STATUS},
@@ -3729,6 +3779,8 @@ SHOW_VAR com_status_vars[]= {
   {"show_grants",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_GRANTS]), SHOW_LONG_STATUS},
   {"show_index_statistics",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_INDEX_STATS]), SHOW_LONG_STATUS},
   {"show_keys",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_KEYS]), SHOW_LONG_STATUS},
+  {"show_lve",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_LVEPROCESSLIST]), SHOW_LONG_STATUS},
+  {"show_lvemem",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_LVEMEMDUMP]), SHOW_LONG_STATUS},
   {"show_master_status",   (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_MASTER_STAT]), SHOW_LONG_STATUS},
   {"show_open_tables",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_OPEN_TABLES]), SHOW_LONG_STATUS},
   {"show_plugins",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_PLUGINS]), SHOW_LONG_STATUS},
@@ -7860,6 +7912,7 @@ SHOW_VAR status_vars[]= {
   {"Delayed_errors",           (char*) &delayed_insert_errors,  SHOW_LONG},
   {"Delayed_insert_threads",   (char*) &delayed_insert_threads, SHOW_LONG_NOFLUSH},
   {"Delayed_writes",           (char*) &delayed_insert_writes,  SHOW_LONG},
+  {"Enable_governor",           (char*) &governor_get_command,  SHOW_INT},
   {"Empty_queries",            (char*) offsetof(STATUS_VAR, empty_queries), SHOW_LONG_STATUS},
   {"Executed_events",          (char*) &executed_events, SHOW_LONG_NOFLUSH },
   {"Executed_triggers",        (char*) offsetof(STATUS_VAR, executed_triggers), SHOW_LONG_STATUS},
@@ -8132,6 +8185,25 @@ static void usage(void)
 }
 #endif /*!EMBEDDED_LIBRARY*/
 
+void governor_set_fn_ptr_to_null(){
+       governor_load_lve_library = NULL;
+       governor_init_lve = NULL;
+       governor_destroy_lve = NULL;
+       governor_enter_lve = NULL;
+       governor_lve_exit = NULL;
+       governor_enter_lve_light = NULL;
+       governor_lve_exit_null = NULL;
+       governor_lve_enter_pid = NULL;
+       governor_is_in_lve = NULL;
+}
+
+void governor_set_fn2_ptr_to_null(){
+       connect_to_server = NULL;
+       send_info_begin = NULL;
+       send_info_end = NULL;
+       close_sock = NULL;
+}
+
 /**
   Initialize MySQL global variables to default values.
 
@@ -8345,6 +8417,127 @@ static int mysql_init_variables(void)
     tmpenv = DEFAULT_MYSQL_HOME;
   strmake_buf(mysql_home, tmpenv);
 #endif
+
+    governor_get_command = 0;
+    connect_to_server = NULL;
+    send_info_begin = NULL;
+    send_info_end = NULL;
+    close_sock = NULL;
+    governor_library_handle = NULL;
+
+    char *error_dl = NULL;
+    governor_library_handle = dlopen("libgovernor.so", RTLD_LAZY);
+    if (governor_library_handle) {
+           sql_print_information("libgovernor.so found");
+           while(1){
+                   connect_to_server = (int (*)())dlsym(governor_library_handle, "connect_to_server");
+                   if ((error_dl = dlerror()) != NULL){
+                           governor_set_fn2_ptr_to_null();
+                           break;
+                   }
+                   send_info_begin = (int (*)(char *))dlsym(governor_library_handle, "send_info_begin");
+                   if ((error_dl = dlerror()) != NULL){
+                           governor_set_fn2_ptr_to_null();
+                           break;
+                   }
+                   send_info_end = (int (*)(char *))dlsym(governor_library_handle, "send_info_end");
+                   if ((error_dl = dlerror()) != NULL){
+                           governor_set_fn2_ptr_to_null();
+                           break;
+                   }
+                   close_sock = (int (*)())dlsym(governor_library_handle, "close_sock");
+                   if ((error_dl = dlerror()) != NULL){
+                           governor_set_fn2_ptr_to_null();
+                           break;
+                   }
+                   sql_print_information("All governors functions found too");
+                   break;
+           }
+   } else {
+           sql_print_information("libgovernor.so not found");
+    }
+    if(connect_to_server){
+           if(!(*connect_to_server)()){
+                   sql_print_information("Governor connected");
+           } else {
+                   sql_print_error("Governor not connected");
+           }
+    }
+    if (governor_library_handle){
+
+           while(1){
+                   governor_load_lve_library = (void * (*)())dlsym(governor_library_handle, "governor_load_lve_library");
+                   if ((error_dl = dlerror()) != NULL){
+                         governor_set_fn_ptr_to_null();
+                         break;
+                   }
+                   governor_init_lve = (int (*)())dlsym(governor_library_handle, "governor_init_lve");
+                   if ((error_dl = dlerror()) != NULL){
+                         governor_set_fn_ptr_to_null();
+                         break;
+                   }
+                   governor_destroy_lve = (void (*)())dlsym(governor_library_handle, "governor_destroy_lve");
+                   if ((error_dl = dlerror()) != NULL){
+                         governor_set_fn_ptr_to_null();
+                     break;
+                   }
+                   governor_enter_lve = (int (*)(uint32_t *, char *))dlsym(governor_library_handle, "governor_enter_lve");
+                   if ((error_dl = dlerror()) != NULL){
+                         governor_set_fn_ptr_to_null();
+                         break;
+                   }
+
+                   governor_lve_exit = (void (*)(uint32_t *))dlsym(governor_library_handle, "governor_lve_exit");
+                   if ((error_dl = dlerror()) != NULL){
+                         governor_set_fn_ptr_to_null();
+                         break;
+                   }
+
+                   governor_enter_lve_light = (int (*)(uint32_t *))dlsym(governor_library_handle, "governor_enter_lve_light");
+                   if ((error_dl = dlerror()) != NULL){
+                         governor_set_fn_ptr_to_null();
+                         break;
+                   }
+
+                   governor_lve_exit_null = (void (*)(void))dlsym(governor_library_handle, "governor_lve_exit_null");
+                   if ((error_dl = dlerror()) != NULL){
+                         governor_set_fn_ptr_to_null();
+                         break;
+                   }
+
+                   governor_lve_enter_pid = (int (*)(pid_t))dlsym(governor_library_handle, "governor_lve_enter_pid");
+                   if ((error_dl = dlerror()) != NULL){
+                         governor_set_fn_ptr_to_null();
+                         break;
+                   }
+
+		   governor_is_in_lve = (int (*)())dlsym(governor_library_handle, "governor_is_in_lve");
+                   if ((error_dl = dlerror()) != NULL){
+                         governor_is_in_lve=NULL;
+                         break;
+                   }
+
+                   sql_print_information("All governors lve functions found too");
+                   break;
+            }
+
+    }
+
+    if(governor_load_lve_library){
+           if(!governor_load_lve_library()){
+                   sql_print_information("Can't get LVE functions");
+           } else {
+		if(governor_init_lve){
+		    if(governor_init_lve()){
+			sql_print_error("Governor LVE initialization error");
+			governor_set_fn_ptr_to_null();
+		    }
+		}
+	   }
+    }
+
+    initialize_lvedebug_info();
+
   return 0;
 }
 
@@ -9060,6 +9253,7 @@ void set_server_version(void)
 #endif
   if (opt_log || opt_slow_log || opt_bin_log)
     strmov(end, "-log");                        // This may slow down system
+  end= strmov(end, "-cll-lve");
 }
 
 
diff -rupN mariadb-10.0.20.old/sql/mysqld.h mariadb-10.0.20.new/sql/mysqld.h
--- mariadb-10.0.20.old/sql/mysqld.h	2015-06-17 17:54:12.000000000 +0300
+++ mariadb-10.0.20.new/sql/mysqld.h	2015-09-27 22:49:38.000000000 +0300
@@ -16,6 +16,8 @@
 #ifndef MYSQLD_INCLUDED
 #define MYSQLD_INCLUDED
 
+#include <stdint.h>
+
 #include "my_global.h" /* MYSQL_PLUGIN_IMPORT, FN_REFLEN, FN_EXTLEN */
 #include "sql_bitmap.h"                         /* Bitmap */
 #include "my_decimal.h"                         /* my_decimal */
@@ -135,6 +137,14 @@ extern ulong opt_tc_log_size, tc_log_max
 extern ulong tc_log_page_waits;
 extern my_bool relay_log_purge, opt_innodb_safe_binlog, opt_innodb;
 extern my_bool relay_log_recovery;
+
+extern volatile int governor_get_command;
+extern int (*connect_to_server)();
+extern int (*send_info_begin)(char *);
+extern int (*send_info_end)(char *);
+extern int (*close_sock)();
+extern void * governor_library_handle;
+
 extern uint test_flags,select_errors,ha_open_options;
 extern uint protocol_version, mysqld_port, dropping_tables;
 extern ulong delay_key_write_options;
@@ -648,6 +658,14 @@ inline query_id_t get_query_id()
 }
 
 
+extern "C" pid_t gettid(void);
+
+void set_governor_variable();
+void set_governor_variable_reconn();
+void set_governor_variable_lve();
+void set_governor_variable_reconn_lve();
+
+
 /*
   TODO: Replace this with an inline function.
  */
diff -rupN mariadb-10.0.20.old/sql/sp_head.cc mariadb-10.0.20.new/sql/sp_head.cc
--- mariadb-10.0.20.old/sql/sp_head.cc	2015-06-17 17:54:12.000000000 +0300
+++ mariadb-10.0.20.new/sql/sp_head.cc	2015-10-02 17:56:41.000000000 +0300
@@ -247,6 +247,8 @@ sp_get_flags_for_command(LEX *lex)
   case SQLCOM_SHOW_VARIABLES:
   case SQLCOM_SHOW_WARNS:
   case SQLCOM_REPAIR:
+  case SQLCOM_SHOW_LVEMEMDUMP:
+  case SQLCOM_SHOW_LVEPROCESSLIST:
     flags= sp_head::MULTI_RESULTS;
     break;
   /*
diff -rupN mariadb-10.0.20.old/sql/sql_acl.cc mariadb-10.0.20.new/sql/sql_acl.cc
--- mariadb-10.0.20.old/sql/sql_acl.cc	2015-06-17 17:54:12.000000000 +0300
+++ mariadb-10.0.20.new/sql/sql_acl.cc	2015-09-27 22:49:38.000000000 +0300
@@ -1263,7 +1263,7 @@ static my_bool acl_load(THD *thd, TABLE_
         {
           /* Starting from 5.0.3 we have max_user_connections field */
           ptr= get_field(thd->mem_root, table->field[next_field++]);
-          user.user_resource.user_conn= ptr ? atoi(ptr) : 0;
+          user.user_resource.user_conn= ptr ? atoll(ptr) : 0;
         }
 
         if (!is_role && table->s->fields >= 41)
@@ -12221,6 +12221,7 @@ bool acl_authenticate(THD *thd, uint com
       can't let the user change max_user_connections from 0 in the server
       without a restart as it would lead to wrong connect counting.
     */
+    
     if ((acl_user->user_resource.questions ||
          acl_user->user_resource.updates ||
          acl_user->user_resource.conn_per_hour ||
diff -rupN mariadb-10.0.20.old/sql/sql_class.cc mariadb-10.0.20.new/sql/sql_class.cc
--- mariadb-10.0.20.old/sql/sql_class.cc	2015-06-17 17:54:12.000000000 +0300
+++ mariadb-10.0.20.new/sql/sql_class.cc	2015-09-27 22:49:38.000000000 +0300
@@ -900,6 +900,8 @@ THD::THD()
 {
   ulong tmp;
 
+  thread_tid_cll = 0;
+
   mdl_context.init(this);
   /*
     We set THR_THD to temporally point to this THD to register all the
@@ -1469,6 +1471,7 @@ void THD::update_all_stats()
 
 void THD::init_for_queries()
 {
+  thread_tid_cll = gettid();
   set_time(); 
   ha_enable_transaction(this,TRUE);
 
diff -rupN mariadb-10.0.20.old/sql/sql_class.h mariadb-10.0.20.new/sql/sql_class.h
--- mariadb-10.0.20.old/sql/sql_class.h	2015-06-17 17:54:12.000000000 +0300
+++ mariadb-10.0.20.new/sql/sql_class.h	2015-09-27 22:49:38.000000000 +0300
@@ -2501,6 +2501,9 @@ public:
       killed= ABORT_QUERY;
   }
 
+  const USER_CONN* get_user_connect()
+  { return user_connect; }
+
   USER_CONN *user_connect;
   CHARSET_INFO *db_charset;
 #if defined(ENABLED_PROFILING)
@@ -2544,6 +2547,7 @@ public:
   ulong      query_plan_flags; 
   ulong      query_plan_fsort_passes; 
   pthread_t  real_id;                           /* For debugging */
+  pid_t      thread_tid_cll;
   my_thread_id  thread_id;
   uint	     tmp_table, global_disable_checkpoint;
   uint	     server_status,open_options;
diff -rupN mariadb-10.0.20.old/sql/sql_cmd.h mariadb-10.0.20.new/sql/sql_cmd.h
--- mariadb-10.0.20.old/sql/sql_cmd.h	2015-06-17 17:54:12.000000000 +0300
+++ mariadb-10.0.20.new/sql/sql_cmd.h	2015-10-03 00:40:49.000000000 +0300
@@ -90,10 +90,12 @@ enum enum_sql_command {
   SQLCOM_SHOW_RELAYLOG_EVENTS,
   SQLCOM_GET_DIAGNOSTICS,
   SQLCOM_SHOW_USER_STATS, SQLCOM_SHOW_TABLE_STATS, SQLCOM_SHOW_INDEX_STATS,
-  SQLCOM_SHOW_CLIENT_STATS,
+  SQLCOM_SHOW_CLIENT_STATS, SQLCOM_SHOW_THREAD_STATS, SQLCOM_ENABLE_GOVERNOR, SQLCOM_ENABLE_RECONN_GOVERNOR,
+  SQLCOM_ENABLE_GOVERNOR_LVE, SQLCOM_ENABLE_RECONN_GOVERNOR_LVE, SQLCOM_LVECMD,
   SQLCOM_SLAVE_ALL_START, SQLCOM_SLAVE_ALL_STOP,
   SQLCOM_SHOW_EXPLAIN, SQLCOM_SHUTDOWN,
   SQLCOM_CREATE_ROLE, SQLCOM_DROP_ROLE, SQLCOM_GRANT_ROLE, SQLCOM_REVOKE_ROLE,
+  SQLCOM_SHOW_LVEPROCESSLIST, SQLCOM_SHOW_LVEMEMDUMP,
 
   /*
     When a command is added here, be sure it's also added in mysqld.cc
diff -rupN mariadb-10.0.20.old/sql/sql_connect.cc mariadb-10.0.20.new/sql/sql_connect.cc
--- mariadb-10.0.20.old/sql/sql_connect.cc	2015-06-17 17:54:12.000000000 +0300
+++ mariadb-10.0.20.new/sql/sql_connect.cc	2015-09-27 22:49:38.000000000 +0300
@@ -1287,6 +1287,7 @@ void prepare_new_connection_state(THD* t
 pthread_handler_t handle_one_connection(void *arg)
 {
   THD *thd= (THD*) arg;
+  thd->thread_tid_cll = gettid();
 
   mysql_thread_set_psi_id(thd->thread_id);
 
diff -rupN mariadb-10.0.20.old/sql/sql_list.cc mariadb-10.0.20.new/sql/sql_list.cc
--- mariadb-10.0.20.old/sql/sql_list.cc	2015-06-17 17:54:12.000000000 +0300
+++ mariadb-10.0.20.new/sql/sql_list.cc	2015-09-27 22:49:38.000000000 +0300
@@ -38,6 +38,14 @@ void free_list(I_List <i_string> *list)
 }
 
 
+void free_list(I_List <i_thd> *list)
+{
+  i_thd *tmp;
+  while ((tmp= list->get()))
+    delete tmp;
+}
+
+
 base_list::base_list(const base_list &rhs, MEM_ROOT *mem_root)
 {
   if (rhs.elements)
diff -rupN mariadb-10.0.20.old/sql/sql_list.h mariadb-10.0.20.new/sql/sql_list.h
--- mariadb-10.0.20.old/sql/sql_list.h	2015-06-17 17:54:12.000000000 +0300
+++ mariadb-10.0.20.new/sql/sql_list.h	2015-09-27 22:49:38.000000000 +0300
@@ -658,6 +658,15 @@ public:
   i_string(const char* s) : ptr(s) {}
 };
 
+/* DB_GOVERNOR ADDITIONS */
+class i_thd: public ilink
+{
+ public:
+   THD* ptr;
+   i_thd():ptr(0) { }
+   i_thd(THD* s) : ptr(s) {}
+};
+
 /* needed for linked list of two strings for replicate-rewrite-db */
 class i_string_pair: public ilink
 {
@@ -811,5 +820,6 @@ list_copy_and_replace_each_value(List<T>
 
 void free_list(I_List <i_string_pair> *list);
 void free_list(I_List <i_string> *list);
+void free_list(I_List <i_thd> *list);
 
 #endif // INCLUDES_MYSQL_SQL_LIST_H
diff -rupN mariadb-10.0.20.old/sql/sql_parse.cc mariadb-10.0.20.new/sql/sql_parse.cc
--- mariadb-10.0.20.old/sql/sql_parse.cc	2015-06-17 17:54:12.000000000 +0300
+++ mariadb-10.0.20.new/sql/sql_parse.cc	2015-10-26 15:57:05.000000000 +0200
@@ -14,6 +14,7 @@
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA */
 
+#define HAVE_CLOCK_GETTIME 1
 #define MYSQL_LEX 1
 #include <my_global.h>
 #include "sql_priv.h"
@@ -99,6 +100,21 @@
 #include "log_slow.h"
 #include "sql_bootstrap.h"
 
+#ifdef  __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+extern void * (*governor_load_lve_library)();
+extern int (*governor_init_lve)();
+extern void (*governor_destroy_lve)();
+extern int (*governor_enter_lve)(uint32_t *, char *);
+extern int (*governor_enter_lve_light)(uint32_t *);
+extern void (*governor_lve_exit)(uint32_t *);
+
+#ifdef  __cplusplus
+}
+#endif
+
 #define FLAGSTR(V,F) ((V)&(F)?#F" ":"")
 
 #ifdef WITH_ARIA_STORAGE_ENGINE
@@ -123,6 +139,8 @@
 static bool execute_sqlcom_select(THD *thd, TABLE_LIST *all_tables);
 static void sql_kill(THD *thd, longlong id, killed_state state, killed_type type);
 static void sql_kill_user(THD *thd, LEX_USER *user, killed_state state);
+static void sql_kill_user(THD *thd, char *user, bool only_kill_query);
+static void sql_kill_user_lve(THD *thd, char *user, bool only_kill_query);
 static bool lock_tables_precheck(THD *thd, TABLE_LIST *tables);
 static bool execute_show_status(THD *, TABLE_LIST *);
 static bool execute_rename_table(THD *, TABLE_LIST *, TABLE_LIST *);
@@ -179,6 +197,52 @@ inline bool all_tables_not_ok(THD *thd, 
 }
 #endif
 
+void set_governor_variable(){
+	governor_get_command = 1;
+}
+
+void set_governor_variable_reconn(){
+	governor_get_command = 1;
+	if(close_sock){
+	     (*close_sock)();
+	}
+	if(connect_to_server){
+	     if(!(*connect_to_server)()){
+	             sql_print_information("Governor reconnected");
+	     } else {
+	             sql_print_error("Governor not reconnected. Failed connection");
+	     }
+	}
+}
+
+void set_governor_variable_lve(){
+       if(!governor_get_command){
+               if(governor_init_lve){
+                       if(governor_init_lve()){
+                               sql_print_error("Governor LVE initialization error");
+                       }
+               }
+       }
+       governor_get_command = 2;
+}
+
+void set_governor_variable_reconn_lve(){
+       set_governor_variable_reconn();
+       governor_get_command = 2;
+       if(governor_init_lve){
+               if(governor_init_lve()){
+                       sql_print_error("Governor LVE initialization error");
+               }
+       }
+}
+
+
+my_bool chek_governors_avaliable_command(THD *thd){
+       return (thd->lex->sql_command!=SQLCOM_ENABLE_GOVERNOR&&thd->lex->sql_command!=SQLCOM_ENABLE_RECONN_GOVERNOR
+                       &&thd->lex->sql_command!=SQLCOM_ENABLE_GOVERNOR_LVE&&thd->lex->sql_command!=SQLCOM_ENABLE_RECONN_GOVERNOR_LVE)&&
+                       (thd->security_ctx && thd->security_ctx->user && thd->security_ctx->user[0]);
+}
+
 
 static bool some_non_temp_table_to_be_updated(THD *thd, TABLE_LIST *tables)
 {
@@ -391,6 +455,8 @@ void init_update_queries(void)
   sql_command_flags[SQLCOM_SHOW_ENGINE_LOGS]= CF_STATUS_COMMAND;
   sql_command_flags[SQLCOM_SHOW_EXPLAIN]= CF_STATUS_COMMAND;
   sql_command_flags[SQLCOM_SHOW_PROCESSLIST]= CF_STATUS_COMMAND;
+  sql_command_flags[SQLCOM_SHOW_LVEPROCESSLIST]= CF_STATUS_COMMAND;
+  sql_command_flags[SQLCOM_SHOW_LVEMEMDUMP]= CF_STATUS_COMMAND;
   sql_command_flags[SQLCOM_SHOW_GRANTS]=      CF_STATUS_COMMAND;
   sql_command_flags[SQLCOM_SHOW_CREATE_DB]=   CF_STATUS_COMMAND;
   sql_command_flags[SQLCOM_SHOW_CREATE]=  CF_STATUS_COMMAND;
@@ -3692,6 +3758,18 @@ end_with_restore_list:
                            thd->security_ctx->priv_user),
                           lex->verbose);
     break;
+  case SQLCOM_SHOW_LVEPROCESSLIST:
+	  if (!thd->security_ctx->priv_user[0] &&
+	    check_global_access(thd,PROCESS_ACL))
+	  break;
+    res=mysqld_show_lvelist(thd);
+    break;
+  case SQLCOM_SHOW_LVEMEMDUMP:
+	  if (!thd->security_ctx->priv_user[0] &&
+	    check_global_access(thd,PROCESS_ACL))
+	  break;
+    res= mysqld_show_lvemem(thd);
+    break;
   case SQLCOM_SHOW_AUTHORS:
     res= mysqld_show_authors(thd);
     break;
@@ -4322,7 +4400,11 @@ end_with_restore_list:
                    MYF(0));
         goto error;
       }
-      sql_kill(thd, it->val_int(), lex->kill_signal, lex->kill_type);
+      if(it->type()==Item::STRING_ITEM){
+         sql_kill_user(thd, it->val_str(0)->c_ptr(), lex->type & ONLY_KILL_QUERY);
+      } else {
+         sql_kill(thd, (ulong)it->val_int(), lex->kill_signal, KILL_TYPE_ID);
+      }
     }
     else
       sql_kill_user(thd, get_current_user(thd, lex->users_list.head()),
@@ -4339,6 +4421,33 @@ end_with_restore_list:
     my_error(ER_NOT_SUPPORTED_YET, MYF(0), "embedded server");
 #endif
     break;
+  case SQLCOM_LVECMD:
+      {
+        Item *it= (Item *)lex->value_list.head();
+
+        if (lex->table_or_sp_used())
+        {
+          my_error(ER_NOT_SUPPORTED_YET, MYF(0), "Usage of subqueries or stored "
+                   "function calls as part of this statement");
+          break;
+        }
+
+        if ((!it->fixed && it->fix_fields(lex->thd, &it)) || it->check_cols(1))
+        {
+          my_message(ER_SET_CONSTANTS_ONLY, ER(ER_SET_CONSTANTS_ONLY),
+                  MYF(0));
+          goto error;
+        }
+
+        if(it->type()==Item::STRING_ITEM){
+           sql_kill_user_lve(thd, it->val_str(0)->c_ptr(), lex->type & ONLY_KILL_QUERY);
+        } else {
+           my_error(ER_NOT_SUPPORTED_YET, MYF(0), "LVE by thread ID is not supported yet");
+        }
+
+
+        break;
+      }
 
 #ifndef NO_EMBEDDED_ACCESS_CHECKS
   case SQLCOM_SHOW_GRANTS:
@@ -6473,6 +6582,16 @@ void mysql_parse(THD *thd, char *rawbuf,
   lex_start(thd);
   mysql_reset_thd_for_next_command(thd);
 
+  if(send_info_begin&&governor_get_command&&chek_governors_avaliable_command(thd)){
+       (*send_info_begin)(thd->security_ctx->user);
+  }
+
+/*  if(governor_enter_lve && (governor_get_command==2) && chek_governors_avaliable_command(thd)){
+         if(thd->security_ctx && thd->security_ctx->user && thd->security_ctx->user[0])
+                 governor_enter_lve(&cookie, thd->security_ctx->user);
+  }*/
+
+
   if (query_cache_send_result_to_client(thd, rawbuf, length) <= 0)
   {
     LEX *lex= thd->lex;
@@ -6525,8 +6644,14 @@ void mysql_parse(THD *thd, char *rawbuf,
                                  &thd->security_ctx->priv_user[0],
                                  (char *) thd->security_ctx->host_or_ip,
                                  0);
-
+          if(governor_enter_lve && (governor_get_command==2) && chek_governors_avaliable_command(thd)){
+		  init_data_lvedebug_info((char *)(thd->query()?thd->query():"No sql"), (char *)(thd->security_ctx->user?thd->security_ctx->user:"unknown"));
+        	  if(put_in_lve(thd->security_ctx->user)<0){
+        	       my_error(ER_GET_ERRNO, MYF(0), "Can't enter into LVE");
+        	  }
+          }
           error= mysql_execute_command(thd);
+          lve_thr_exit();
           MYSQL_QUERY_EXEC_DONE(error);
 	}
       }
@@ -6560,6 +6685,15 @@ void mysql_parse(THD *thd, char *rawbuf,
     status_var_increment(thd->status_var.com_stat[SQLCOM_SELECT]);
     thd->update_stats();
   }
+
+/*  if(governor_lve_exit && (governor_get_command==2) && cookie &&chek_governors_avaliable_command(thd)){
+         governor_lve_exit(&cookie);
+  }*/
+
+  if(send_info_end&&governor_get_command&&chek_governors_avaliable_command(thd)){
+         (*send_info_end)(thd->security_ctx->user);
+  }
+
   DBUG_VOID_RETURN;
 }
 
@@ -7597,6 +7731,24 @@ void sql_kill_user(THD *thd, LEX_USER *u
   }
 }
 
+static void sql_kill_user(THD *thd, char *user, bool only_kill_query)
+{
+  uint error;
+  if (!(error= kill_user_thread(thd, user, only_kill_query))){
+	  if (! thd->killed) my_ok(thd);
+  } else
+    my_error(error, MYF(0), user);
+}
+
+void sql_kill_user_lve(THD *thd, char *user, bool only_kill_query)
+{
+  uint error;
+  if (!(error= kill_user_thread_lve(thd, user, only_kill_query)))
+    my_ok(thd);
+  else
+    my_error(error, MYF(0), user);
+}
+
 
 /** If pointer is not a null pointer, append filename to it. */
 
@@ -8669,3 +8821,106 @@ merge_charset_and_collation(CHARSET_INFO
   }
   return cs;
 }
+
+
+uint kill_user_thread(THD *thd, char *user, bool only_kill_query)
+{
+  THD *tmp;
+  uint error=0;
+  DBUG_ENTER("kill_user_thread");
+  DBUG_PRINT("enter", ("id=%s only_kill=%d", !user?"nop":user, only_kill_query));
+  i_thd *thd_tmp;
+  I_List<i_thd> threads_tmp;
+  threads_tmp.empty();
+  mysql_mutex_lock(&LOCK_thread_count); // For unlink from list
+  I_List_iterator<THD> it(threads);
+  while ((tmp=it++))
+  {
+	if (tmp->get_command() == COM_DAEMON)
+		continue;
+    if(user&&(tmp->get_user_connect())&&(tmp->get_user_connect()->user)){
+      if (!strncmp(tmp->get_user_connect()->user,user,16))
+      {
+    	mysql_mutex_lock(&tmp->LOCK_thd_data);  // Lock from delete
+        thd_tmp = new i_thd(tmp);
+        if (thd_tmp) threads_tmp.append(thd_tmp);
+        else mysql_mutex_unlock(&tmp->LOCK_thd_data);
+      }
+    }
+  }
+  mysql_mutex_unlock(&LOCK_thread_count);
+
+  if(!threads_tmp.is_empty())
+  {
+	  I_List_iterator<i_thd> it_tmp(threads_tmp);
+	  while ((thd_tmp=it_tmp++)){
+	      tmp=thd_tmp->ptr;
+
+	      if ((thd->security_ctx->master_access & SUPER_ACL) ||
+	    		  thd->security_ctx->user_matches(tmp->security_ctx))
+	      {
+	    	  tmp->awake(only_kill_query ? KILL_QUERY : KILL_CONNECTION);
+	    	  error=0;
+	      }
+	      else
+    	  error=ER_KILL_DENIED_ERROR;
+	      mysql_mutex_unlock(&tmp->LOCK_thd_data);
+  	  }
+	  free_list(&threads_tmp);
+	  threads_tmp.empty();
+  }
+  DBUG_PRINT("exit", ("%d", error));
+  DBUG_RETURN(error);
+}
+
+uint kill_user_thread_lve(THD *thd, char *user, bool only_kill_query)
+{
+
+  DBUG_ENTER("kill_user_thread_lve");
+  THD *tmp;
+  i_thd *thd_tmp;
+  I_List<i_thd> threads_tmp;
+  threads_tmp.empty();
+  uint error=0;//ER_NO_SUCH_THREAD_USER;
+  mysql_mutex_lock(&LOCK_thread_count); // For unlink from list
+  I_List_iterator<THD> it(threads);
+  while ((tmp=it++))
+  {
+    if(user&&(tmp->get_user_connect())&&(tmp->get_user_connect()->user)){
+      if (!strncmp(tmp->get_user_connect()->user,user,16))
+      {
+    	  mysql_mutex_lock(&tmp->LOCK_thd_data);  // Lock from delete
+        thd_tmp = new i_thd(tmp);
+        if (thd_tmp) threads_tmp.append(thd_tmp);
+        else mysql_mutex_unlock(&tmp->LOCK_thd_data);
+      }
+    }
+  }
+  mysql_mutex_unlock(&LOCK_thread_count);
+
+  if(!threads_tmp.is_empty()){
+         I_List_iterator<i_thd> it_tmp(threads_tmp);
+         while ((thd_tmp=it_tmp++)){
+                  tmp=thd_tmp->ptr;
+                 if ((thd->security_ctx->master_access & SUPER_ACL) ||
+                      thd->security_ctx->user_matches(tmp->security_ctx))
+                 {
+                   if(tmp->thread_tid_cll){
+                       governor_setlve_mysql_thread_info(tmp->thread_tid_cll);
+                   }
+                 } else {
+                         error=ER_KILL_DENIED_ERROR;
+                 }
+                 mysql_mutex_unlock(&tmp->LOCK_thd_data);
+
+         }
+         free_list(&threads_tmp);
+         threads_tmp.empty();
+  }
+
+  DBUG_RETURN(error);
+
+}
+
+
+
diff -rupN mariadb-10.0.20.old/sql/sql_parse.h mariadb-10.0.20.new/sql/sql_parse.h
--- mariadb-10.0.20.old/sql/sql_parse.h	2015-06-17 17:54:12.000000000 +0300
+++ mariadb-10.0.20.new/sql/sql_parse.h	2015-09-27 22:49:38.000000000 +0300
@@ -53,6 +53,9 @@ bool check_fk_parent_table_access(THD *t
 bool parse_sql(THD *thd, Parser_state *parser_state,
                Object_creation_ctx *creation_ctx, bool do_pfs_digest=false);
 
+uint kill_user_thread(THD *thd, char *user, bool only_kill_query);
+uint kill_user_thread_lve(THD *thd, char *user, bool only_kill_query);
+
 void free_items(Item *item);
 void cleanup_items(Item *item);
 
diff -rupN mariadb-10.0.20.old/sql/sql_prepare.cc mariadb-10.0.20.new/sql/sql_prepare.cc
--- mariadb-10.0.20.old/sql/sql_prepare.cc	2015-09-27 22:40:54.187375214 +0300
+++ mariadb-10.0.20.new/sql/sql_prepare.cc	2015-09-27 22:49:38.000000000 +0300
@@ -2214,6 +2214,7 @@ static bool check_prepared_statement(Pre
   case SQLCOM_REVOKE:
   case SQLCOM_KILL:
   case SQLCOM_SHUTDOWN:
+  case SQLCOM_LVECMD:
     break;
 
   case SQLCOM_PREPARE:
diff -rupN mariadb-10.0.20.old/sql/sql_select.cc mariadb-10.0.20.new/sql/sql_select.cc
--- mariadb-10.0.20.old/sql/sql_select.cc	2015-06-17 17:54:12.000000000 +0300
+++ mariadb-10.0.20.new/sql/sql_select.cc	2015-09-27 22:49:38.000000000 +0300
@@ -17161,6 +17161,7 @@ create_internal_tmp_table_from_heap(THD 
 
   save_proc_info=thd->proc_info;
   THD_STAGE_INFO(thd, stage_converting_heap_to_myisam);
+  my_reserve_slot();
 
   new_table.no_rows= table->no_rows;
   if (create_internal_tmp_table(&new_table, table->key_info, start_recinfo,
@@ -17173,8 +17174,10 @@ create_internal_tmp_table_from_heap(THD 
   if (table->file->indexes_are_disabled())
     new_table.file->ha_disable_indexes(HA_KEY_SWITCH_ALL);
   table->file->ha_index_or_rnd_end();
-  if (table->file->ha_rnd_init_with_error(1))
+  if (table->file->ha_rnd_init_with_error(1)){
+    my_release_slot();
     DBUG_RETURN(1);
+  }
   if (new_table.no_rows)
     new_table.file->extra(HA_EXTRA_NO_ROWS);
   else
@@ -17235,6 +17238,7 @@ create_internal_tmp_table_from_heap(THD 
   if (save_proc_info)
     thd_proc_info(thd, (!strcmp(save_proc_info,"Copying to tmp table") ?
                   "Copying to tmp table on disk" : save_proc_info));
+  my_release_slot();
   DBUG_RETURN(0);
 
  err:
@@ -17246,6 +17250,7 @@ err_killed:
  err1:
   new_table.file->ha_delete_table(new_table.s->table_name.str);
  err2:
+  my_release_slot();
   delete new_table.file;
   thd_proc_info(thd, save_proc_info);
   table->mem_root= new_table.mem_root;
diff -rupN mariadb-10.0.20.old/sql/sql_show.cc mariadb-10.0.20.new/sql/sql_show.cc
--- mariadb-10.0.20.old/sql/sql_show.cc	2015-06-17 17:54:12.000000000 +0300
+++ mariadb-10.0.20.new/sql/sql_show.cc	2015-10-26 16:07:34.000000000 +0200
@@ -367,6 +367,81 @@ int fill_all_plugins(THD *thd, TABLE_LIS
   DBUG_RETURN(0);
 }
 
+bool mysqld_show_lvemem(THD *thd)
+{
+  List<Item> field_list;
+  Protocol *protocol= thd->protocol;
+  char mem_buffer[64] = {0};
+  DBUG_ENTER("mysqld_show_lvemem");
+  snprintf(mem_buffer, 63, "%ld", get_memusage_lvedebug_info());
+
+  field_list.push_back(new Item_empty_string("Mem_Usage",300));
+
+  if (protocol->send_result_set_metadata(&field_list,
+                            Protocol::SEND_NUM_ROWS | Protocol::SEND_EOF))
+    DBUG_RETURN(TRUE);
+
+  protocol->prepare_for_resend();
+  protocol->store((const char *)mem_buffer, system_charset_info);
+  if (protocol->write())
+      DBUG_RETURN(TRUE);
+
+  my_eof(thd);
+  DBUG_RETURN(FALSE);
+}
+
+bool mysqld_show_lvelist(THD *thd)
+{
+  List<Item> field_list;
+  Protocol *protocol= thd->protocol;
+  char pid[10] = {0}, is_in_lve[10] = {0}, chk_is_in_lve[10] = {0}, sql[50] = {0}, debug[200] = {0};
+
+  field_list.push_back(new Item_empty_string("PID",10));
+  field_list.push_back(new Item_empty_string("IS_IN_LVE",5));
+  field_list.push_back(new Item_empty_string("CHECK_IS_IN_LVE",5));
+  field_list.push_back(new Item_empty_string("SQL",50));
+  field_list.push_back(new Item_empty_string("DEBUG",200));
+
+  if (protocol->send_result_set_metadata(&field_list,
+                            Protocol::SEND_NUM_ROWS | Protocol::SEND_EOF))
+    DBUG_RETURN(TRUE);
+
+  void *ptr = init_info_retarray_lvedbug_info(1000);
+  if(ptr){
+
+	  int res = send_to_client_debug_data_lvedebug_info(ptr, 1000);
+	  int index = 0;
+	  for (index = 0; index < res; index++)
+	  {
+		  bzero(pid, 10*sizeof(char));
+		  bzero(is_in_lve, 10*sizeof(char));
+		  bzero(chk_is_in_lve, 10*sizeof(char));
+		  bzero(sql, 50*sizeof(char));
+		  bzero(debug, 200*sizeof(char));
+		  protocol->prepare_for_resend();
+		  retinfo_info_retarray_lvedbug_info(pid, 0, ptr, index, 9);
+		  retinfo_info_retarray_lvedbug_info(is_in_lve, 1, ptr, index, 9);
+		  retinfo_info_retarray_lvedbug_info(chk_is_in_lve, 2, ptr, index, 9);
+		  retinfo_info_retarray_lvedbug_info(sql, 3, ptr, index, 49);
+		  retinfo_info_retarray_lvedbug_info(debug, 4, ptr, index, 199);
+
+		  protocol->store((const char *)pid, system_charset_info);
+		  protocol->store((const char *)is_in_lve, system_charset_info);
+		  protocol->store((const char *)chk_is_in_lve, system_charset_info);
+		  protocol->store((const char *)sql, system_charset_info);
+		  protocol->store((const char *)debug, system_charset_info);
+		  if (protocol->write()){
+			  release_info_retarray_lvedbug_info(ptr);
+			  DBUG_RETURN(TRUE);
+		  }
+	  }
+	  release_info_retarray_lvedbug_info(ptr);
+  }
+  my_eof(thd);
+
+  DBUG_RETURN(FALSE);
+}
+
 
 /***************************************************************************
 ** List all Authors.
diff -rupN mariadb-10.0.20.old/sql/sql_show.h mariadb-10.0.20.new/sql/sql_show.h
--- mariadb-10.0.20.old/sql/sql_show.h	2015-06-17 17:54:12.000000000 +0300
+++ mariadb-10.0.20.new/sql/sql_show.h	2015-10-03 00:54:40.000000000 +0300
@@ -97,6 +97,8 @@ bool mysqld_show_storage_engines(THD *th
 bool mysqld_show_authors(THD *thd);
 bool mysqld_show_contributors(THD *thd);
 bool mysqld_show_privileges(THD *thd);
+bool mysqld_show_lvemem(THD *thd);
+bool mysqld_show_lvelist(THD *thd);
 char *make_backup_log_name(char *buff, const char *name, const char* log_ext);
 void calc_sum_of_all_status(STATUS_VAR *to);
 void append_definer(THD *thd, String *buffer, const LEX_STRING *definer_user,
diff -rupN mariadb-10.0.20.old/sql/sql_yacc.yy mariadb-10.0.20.new/sql/sql_yacc.yy
--- mariadb-10.0.20.old/sql/sql_yacc.yy	2015-06-17 17:54:12.000000000 +0300
+++ mariadb-10.0.20.new/sql/sql_yacc.yy	2015-10-02 18:23:12.000000000 +0300
@@ -1142,6 +1142,10 @@ bool my_yyoverflow(short **a, YYSTYPE **
 %token  ELSE                          /* SQL-2003-R */
 %token  ELSEIF_SYM
 %token  ENABLE_SYM
+%token  ENABLE_GOVERNOR_SYM
+%token  ENABLE_GOVERNOR_RECONN_SYM
+%token  ENABLE_GOVERNOR_LVE_SYM
+%token  ENABLE_GOVERNOR_RECONN_LVE_SYM
 %token  ENCLOSED
 %token  END                           /* SQL-2003-R */
 %token  ENDS_SYM
@@ -1279,6 +1283,9 @@ bool my_yyoverflow(short **a, YYSTYPE **
 %token  LOOP_SYM
 %token  LOW_PRIORITY
 %token  LT                            /* OPERATOR */
+%token  LVECMD_SYM
+%token  LVEMEM_SYM
+%token  LVEPROCESS_SYM
 %token  MASTER_CONNECT_RETRY_SYM
 %token  MASTER_GTID_POS_SYM
 %token  MASTER_HOST_SYM
@@ -1820,7 +1827,7 @@ bool my_yyoverflow(short **a, YYSTYPE **
         persistent_column_stat_spec persistent_index_stat_spec
         table_column_list table_index_list table_index_name
         check start checksum
-        field_list field_list_item field_spec kill column_def key_def
+        field_list field_list_item field_spec kill lvecmd column_def key_def
         keycache_list keycache_list_or_parts assign_to_keycache
         assign_to_keycache_parts
         preload_list preload_list_or_parts preload_keys preload_keys_parts
@@ -2007,6 +2014,10 @@ statement:
         | describe
         | do
         | drop
+        | enable_governor
+        | enable_governor_reconn
+        | enable_governor_lve
+        | enable_governor_reconn_lve
         | execute
         | flush
         | get_diagnostics
@@ -2020,6 +2031,7 @@ statement:
         | kill
         | load
         | lock
+        | lvecmd
         | optimize
         | parse_vcol_expr
         | partition_entry
@@ -8129,6 +8141,22 @@ opt_view_check_type:
         | FOR_SYM UPGRADE_SYM { Lex->check_opt.sql_flags|= TT_FOR_UPGRADE; }
         ;
 
+       
+lvecmd:
+          LVECMD_SYM lvecmd_option expr
+          {
+            LEX *lex=Lex;
+            lex->value_list.empty();
+            lex->value_list.push_front($3);
+            lex->sql_command= SQLCOM_LVECMD;
+          }
+        ;
+
+lvecmd_option:
+          /* empty */ { Lex->type= ONLY_KILL_QUERY; }
+        ;
+ 
+
 optimize:
           OPTIMIZE opt_no_write_to_binlog table_or_tables
           {
@@ -12318,6 +12346,41 @@ opt_profile_args:
     }
   ;
 
+enable_governor:
+          ENABLE_GOVERNOR_SYM
+          {
+            LEX *lex= Lex;
+            lex->sql_command= SQLCOM_ENABLE_GOVERNOR;
+            set_governor_variable();
+          }
+         ;
+
+enable_governor_reconn:
+          ENABLE_GOVERNOR_RECONN_SYM
+          {
+            LEX *lex= Lex;
+            lex->sql_command= SQLCOM_ENABLE_RECONN_GOVERNOR;
+            set_governor_variable_reconn();
+          }
+         ;
+enable_governor_lve:
+          ENABLE_GOVERNOR_LVE_SYM
+          {
+            LEX *lex= Lex;
+            lex->sql_command= SQLCOM_ENABLE_GOVERNOR_LVE;
+            set_governor_variable_lve();
+          }
+         ;
+
+enable_governor_reconn_lve:
+          ENABLE_GOVERNOR_RECONN_LVE_SYM
+          {
+            LEX *lex= Lex;
+            lex->sql_command= SQLCOM_ENABLE_RECONN_GOVERNOR_LVE;
+            set_governor_variable_reconn_lve();
+          }
+         ;
+
 /* Show things */
 
 show:
@@ -12493,6 +12556,16 @@ show_param:
           }
         | opt_full PROCESSLIST_SYM
           { Lex->sql_command= SQLCOM_SHOW_PROCESSLIST;}
+        | LVEPROCESS_SYM
+          { 
+          	LEX *lex=Lex;
+          	Lex->sql_command= SQLCOM_SHOW_LVEPROCESSLIST;
+          }
+        | LVEMEM_SYM
+          { 
+          	LEX *lex=Lex;
+          	Lex->sql_command= SQLCOM_SHOW_LVEMEMDUMP;
+          }
         | opt_var_type  VARIABLES wild_and_where
           {
             LEX *lex= Lex;
diff -rupN mariadb-10.0.20.old/storage/innobase/include/os0file.h mariadb-10.0.20.new/storage/innobase/include/os0file.h
--- mariadb-10.0.20.old/storage/innobase/include/os0file.h	2015-06-17 17:54:13.000000000 +0300
+++ mariadb-10.0.20.new/storage/innobase/include/os0file.h	2015-09-27 22:49:38.000000000 +0300
@@ -224,6 +224,7 @@ are used to register file deletion opera
 # define register_pfs_file_open_begin(state, locker, key, op, name,	\
 				      src_file, src_line)		\
 do {									\
+        my_reserve_slot();					        \
 	locker = PSI_FILE_CALL(get_thread_file_name_locker)(		\
 		state, key, op, name, &locker);				\
 	if (UNIV_LIKELY(locker != NULL)) {				\
@@ -238,11 +239,13 @@ do {									\
 		PSI_FILE_CALL(end_file_open_wait_and_bind_to_descriptor)(\
 			locker, file);					\
 	}								\
+	my_release_slot();						\
 } while (0)
 
 # define register_pfs_file_close_begin(state, locker, key, op, name,	\
 				      src_file, src_line)		\
 do {									\
+        my_reserve_slot();					        \
 	locker = PSI_FILE_CALL(get_thread_file_name_locker)(		\
 		state, key, op, name, &locker);				\
 	if (UNIV_LIKELY(locker != NULL)) {				\
@@ -257,11 +260,13 @@ do {									\
 		PSI_FILE_CALL(end_file_close_wait)(			\
 			locker, result);				\
 	}								\
+	my_release_slot();						\
 } while (0)
 
 # define register_pfs_file_io_begin(state, locker, file, count, op,	\
 				    src_file, src_line)			\
 do {									\
+        my_reserve_slot();					        \
 	locker = PSI_FILE_CALL(get_thread_file_descriptor_locker)(	\
 		state, file, op);					\
 	if (UNIV_LIKELY(locker != NULL)) {				\
@@ -275,6 +280,7 @@ do {									\
 	if (UNIV_LIKELY(locker != NULL)) {				\
 		PSI_FILE_CALL(end_file_wait)(locker, count);		\
 	}								\
+	my_release_slot();						\
 } while (0)
 #endif /* UNIV_PFS_IO  */
 
diff -rupN mariadb-10.0.20.old/support-files/mysql.server.sh mariadb-10.0.20.new/support-files/mysql.server.sh
--- mariadb-10.0.20.old/support-files/mysql.server.sh	2015-06-17 17:54:14.000000000 +0300
+++ mariadb-10.0.20.new/support-files/mysql.server.sh	2015-09-27 22:49:38.000000000 +0300
@@ -59,6 +59,20 @@ lock_file_path="$lockdir/mysql"
 
 # The following variables are only set for letting mysql.server find things.
 
+if [ -e /usr/share/lve/dbgovernor/utils/mysql_export ]; then
+. /usr/share/lve/dbgovernor/utils/mysql_export
+else
+get_limit(){
+    return
+}
+set_big_limit(){
+    return
+}
+set_old_limit(){
+    return
+}
+fi
+
 # Set some defaults
 mysqld_pid_file_path=
 if test -z "$basedir"
@@ -326,6 +340,11 @@ case "$mode" in
   'stop')
     # Stop daemon. We use a signal here to avoid having to know the
     # root password.
+    
+    get_limit
+    set_big_limit
+    sleep 2
+    
 
     if test -s "$mysqld_pid_file_path"
     then
@@ -347,10 +366,12 @@ case "$mode" in
       then
         rm -f "$lock_file_path"
       fi
+      set_old_limit
       exit $return_value
     else
       log_failure_msg "MySQL server PID file could not be found!"
     fi
+    set_old_limit
     ;;
 
   'restart')
@@ -365,14 +386,19 @@ case "$mode" in
     ;;
 
   'reload'|'force-reload')
+    get_limit
+    set_big_limit
+    sleep 2
     if test -s "$mysqld_pid_file_path" ; then
       read mysqld_pid <  "$mysqld_pid_file_path"
       kill -HUP $mysqld_pid && log_success_msg "Reloading service MySQL"
       touch "$mysqld_pid_file_path"
     else
       log_failure_msg "MySQL PID file could not be found!"
+      set_old_limit
       exit 1
     fi
+    set_old_limit
     ;;
   'status')
     # First, check to see if pid file exists
